# MySQL架构设计学习笔记

  * [第一章 数据库概述](#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0)
    * [1\.1 影响数据库性能的因素](#11-%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0)
    * [1\.2 这些因素带来的风险](#12-%E8%BF%99%E4%BA%9B%E5%9B%A0%E7%B4%A0%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%A3%8E%E9%99%A9)
    * [1\.3 事务概述](#13-%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0)
      * [1\.3\.1 事务的概念](#131-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5)
      * [1\.3\.2 事务的四大特性](#132-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7)
      * [1\.3\.3 事务的四大特性概念](#133-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E6%A6%82%E5%BF%B5)
      * [1\.3\.4\. 大事务](#134-%E5%A4%A7%E4%BA%8B%E5%8A%A1)
      * [1\.3\.5 锁](#135-%E9%94%81)
  * [第二章 数据库性能](#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD)
    * [2\.1 影响性能的几个方面](#21-%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2)
      * [2\.1\.1 CPU资源和可用内存大小](#211-cpu%E8%B5%84%E6%BA%90%E5%92%8C%E5%8F%AF%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F)
      * [2\.1\.2 磁盘的配置和选择](#212-%E7%A3%81%E7%9B%98%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E9%80%89%E6%8B%A9)
      * [2\.1\.3 服务器硬件对性能的影响](#213-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D)
      * [2\.1\.4 操作系统对性能的影响](#214-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D)
      * [2\.1\.5 存储引擎对性能的影响](#215-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D)
      * [2\.1\.6 如何选择正确的存储引擎](#216-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
    * [2\.2 MySQL服务器参数](#22-mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%82%E6%95%B0)
    * [2\.3 数据库设计对性能的影响](#23-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D)
  * [第三章 MySQL基准测试](#%E7%AC%AC%E4%B8%89%E7%AB%A0-mysql%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95)
    * [3\.1 基准测试定义：](#31-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%AE%9A%E4%B9%89)
    * [3\.2 基准测试与压力测试的区别：](#32-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB)
    * [3\.3 基准测试目的：](#33-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%9B%AE%E7%9A%84)
    * [3\.4 基准测试方法：](#34-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95)
    * [3\.5 常用基准测试用具](#35-%E5%B8%B8%E7%94%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%94%A8%E5%85%B7)
  * [第四章 数据库优化](#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96)
    * [4\.1 数据库结构优化](#41-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96)
    * [4\.2 物理设计](#42-%E7%89%A9%E7%90%86%E8%AE%BE%E8%AE%A1)
      * [4\.2\.1 命名规范](#421-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83)
      * [4\.2\.2 选择合适的存储引擎](#422-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
      * [4\.2\.3 选择合适的数据类型](#423-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
      * [4\.2\.4 为Innodb选择合适主键](#424-%E4%B8%BAinnodb%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E4%B8%BB%E9%94%AE)
  * [第五章 数据库架构设计](#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1)
    * [5\.1 MySQL主从复制](#51-mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6)

## 第一章 数据库概述

### 1.1 影响数据库性能的因素

- sql查询速度
- 服务器硬件
- 磁盘IO
- 网卡带宽
- 数据库大表

### 1.2 这些因素带来的风险

1）超高的QPS（每秒处理的查询数）和TPS（每秒事务处理）

​	风险：效率低下的SQL会让数据库崩溃。

2）大量的并发和超高的CPU使用率

​	风险：①大量的并发：使数据库连接数被占满（max_connections默认100）；②超高的CPU使用率：因CPU资源耗尽而出现宕机。

3）磁盘IO

​	风险：①磁盘IO性能突然下降；②其他大量消耗磁盘性能的计划任务。

​	解决办法：①使用更快的磁盘设备；②调整计划任务，做好磁盘维护。

4）网卡带宽

​	风险：网卡IO被占满。

​	解决办法：①减少**从服务器**数量；②进行分级缓存；③避免使用 "SELECT *"进行查询 ；④分离业务网络和服务器网络。

5）数据库大表

**1. 概念**

​	**数据库大表**指的是：记录行数巨大，单表超过千万行；表数据文件巨大，表数据文件超过10G。

​	大表对**查询**的影响：慢查询，即很难在一定的时间过滤出所需要的	数据。

**2. 影响**

​	大表对**DDL操作**的影响：

​	①建立索引需要很长的时间。

​	风险：MSQL版本<5.5 建立索引会锁表；MYSQL版本>=5.5 引起主从延迟但不锁表。

​	②修改表结构需要长时间锁表。

​	风险：会造成长时间的主从延迟，影响正常的数据操作。

**3. 解决办法**

​	①分库分表把一张大表分成多个小表。（难点：分表主键的选择；分表后跨分区数据的查询和统计）

​	②大表的历史数据归档，减少对前后端业务的影响（难点：归档时间点的选择；如何进行归档操作）

### 1.3 事务概述

#### 1.3.1 事务的概念

​	①事务是数据库系统区别于其他一切文件系统的重要特性之一；

​	②事务是一组具有原子性的SQL语句，或是一个独立的工作单元。

#### 1.3.2 事务的四大特性

- 原子性
- 一致性
- 隔离性
- 持久性

#### 1.3.3 事务的四大特性概念

​	①**事务的原子性（ATOMICITY）**

​	定义：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作。

​	②**事务的一致性（CONSISTENCY）**

​	定义：一致性是指事务将数据库从一种一致性状态转换到另外一种一致性状态，在事务开始之前和事务结束后数据库中数据的完整性没有被破坏。

​	③**事务的隔离性（ISOLATION）**

​	定义：隔离性要求一个事务对数据库中的数据的修改，在未提交完成前对于其他事务是不可见的。

​	SQL标准中定义的四种隔离级别：

- 未提交读（READ UNCOMMITED）（也称作脏读：通常不建议使用）

- 已提交读（READ COMMITED）（SQL Server、Oracle的默认级别，也称作不可重复读）

- 可重复读（REPEATABLE READ）（MYSQL的默认级别）

- 可串行化（SERIALIZABLE）

  **隔离性由低到高，并发性由高到低。**

​	④**事务的持久性（DURABILITY）**

​	定义：一旦事务提交，则其所作的修改就会永久保存到数据库中。此时即时系统崩溃，已经提交的修改数据也不会丢失。

#### 1.3.4. 大事务

​	定义：运行时间比较长，操作的数据比较多的事务。

​	风险：①锁定太多的数据，造成大量的阻塞和锁超时；②回滚所需时间比较长；③执行时间长，容易造成主从延迟。

​	如何处理大事务：

- 避免一次性处理太多的数据；
- 移出没必要在事物中的SELECT操作。

#### 1.3.5 锁

**1. 什么是锁**

​	（1）锁的主要作用是管理共享资源的并发访问

​	（2）锁用于实现事务的隔离性

**2. 锁的类型**

​	（1）共享锁（读锁）

​	（2）独占锁（写锁）

|      | 写锁   | 读锁   |
| ---- | ------ | ------ |
| 写锁 | 不兼容 | 不兼容 |
| 读锁 | 不兼容 | 兼容   |

**3. 锁的粒度**

​	（1）表级锁（开销小，并发性能低）

​	（2）行级锁（开销大，并发性能高）

## 第二章 数据库性能

### 2.1 影响性能的几个方面

- **服务器硬件配置**
- **服务器系统**
- **数据库存储引擎的选择**（MyISAM：不支持事务，表级锁；InnoDB：事务级存储引擎，完美支持行级锁，事务ACID特性。）
- **数据库参数配置**
- **数据库结构设计和SQL语句的编写和优化**

#### 2.1.1 CPU资源和可用内存大小

**1.  CPU资源：**

​	MYSQL不支持多CPU对同一SQL的并发处理。

​	MYSQL高版本（5.6以上）对CPU多核心进行了优化与支持。

​	Web类应用：CPU核心数量比频率更重要。

**2. 内存大小**

​	常用的MySQL存储引擎：

- MyISAM：索引缓存在内存中，数据通过OS处理。
- InnoDB：索引和数据都缓存在内存中。

​	选择主板支持的最大内存频率的内存：

- 组成购买升级
- 每个通道的内存：相同品牌、颗粒
- 频率、电压’校验技术和型号
- 单条容量尽可能大（根据数据库热数据大小选择内存）

#### 2.1.2 磁盘的配置和选择

- 使用传统机器硬盘
- 使用RAID增强传统机器硬盘的性能
- 使用固态存储SSD和PCIe卡
- 使用网络存储NAS和SAN

**1.  传统机器硬盘**

​	优缺点：价格低，使用最多，最常见，存储空间大，但是读/写较慢。

​	磁盘读取数据过程：

- ①移动磁头到磁盘表面上的正确位置；
- ②等待磁盘旋转，使得所需的数据在磁头下；（访问：①->②）
- ③等待磁盘旋转过去，所有所需的数据都被磁头读出。（传输：③）

​	选择考虑因素：

- 存储容量
- 传输速度
- 访问时间
- 主轴转速
- 物理尺寸

**2.  RAID增强传统机器硬盘的性能**

​	定义：RAID是磁盘冗余队列的简称（Redundant Arrays of Independent Disks）。

​	作用：把多个容量较小的磁盘组成一组容量，并且提供数据冗余来保证数据完整性的技术。

​	**常用的RAID级别：**

​	（1）**RAID 0**：称为数据条带。是组建磁盘阵列中*最简单的一种形式*，只需要两块以上的硬盘即可，*成本低*，可以提高整个磁盘的性能和吞吐量，RAID 0*没有提供冗余或错误修复能力*，但是实现成本是最低的。

​	（2）**RAID 1**：称为磁盘镜像，原理：数据在写入一块磁盘的同时，会在另一块磁盘上生成镜像文件，在不影响性能的情况下*最大限度的保证系统的可靠性和可修复性*。

​	（3）**RAID 5**：称为分布式奇偶校验磁盘阵列，它通过分布式奇偶校验块把*数据分散到多个磁盘上*，这样若任何一个盘数据丢失，都可以从奇偶校验块中重建；若两块磁盘均丢失，则整个数据都无法恢复。（常用在**从服务器**上）

​	（4）**RAID 10**：称为分片的镜像，它是对磁盘先做RAID 1 后对两组RAID 1 的磁盘再做RAID 0 ，所以读写性能良好，相对于RAID 5 重建更简单，速度更快。

​	**常用RAID级别对比**

|  等级   |        特点        | 是否冗余 | 盘数 |  读  |       写       |
| :-----: | :----------------: | :------: | :--: | :--: | :------------: |
| RAID 0  |  便宜、快速、危险  |    否    |  N   |  快  |       快       |
| RAID 1  | 高速读、简单、安全 |    是    |      |  快  |       慢       |
| RAID 5  |   成本折中、安全   |    是    | N+1  |  快  | 取决于最慢的盘 |
| RAID 10 |   贵、高速、安全   |    是    |  2N  |  快  |       快       |

**3.  使用固态存储SSD或PCIe卡**

​	优点：相比机械磁盘固态磁盘有更好的随机读写性能，能更好的支持并发。

​	缺点：相比机械磁盘固态磁盘更容易损坏。

​	**SSD的特点**

- 使用SATA接口，可无缝替换机械硬盘而无需额外工作
- SATA接口的SSD同样支持RAID技术

​	**固态存储的使用场景**

- 适用于存在大量随机I/O的场景
- 适用于解决单线程负载的I/O瓶颈

**4.  网络存储SAN和NAS**

​	SAN（Storage Area Network）和NAS（Network-Attached Storage）是两种外部文件存储设备加载到服务器上的方法。

​	**SAN设备**

​	通过光纤连接到服务器，设备通过块接口访问，服务器可以将其当做硬盘使用。

​	优点是：支持大量顺序读写，读写I/O、缓存和I/O合并；缺点是：随机读写慢，不如本地RAID磁盘。

​	**NAS设备**

​	使用网络连接，通过基于文件的协议如NFS或SMB协议来访问。

​	缺点是：读写会有网络延迟。

​	**网络存储的适用场景**

- 数据库备份

​	**如何改善网络对性能的影响：**

- 采用高性能和高带宽的网络接口设备和交换机
- 对多个网卡进行绑定，增强可用性和带宽
- 尽可能的进行网络隔离

#### 2.1.3 服务器硬件对性能的影响

**1. CPU**

- 64位的CPU一定要工作在64位的系统下
- 对于并发较高的场景CPU的（核心）数量要比频率更重要
- 对于CPU密集型场景和复杂SQL则频率越高越好

**2. 内存**

- 优先选择主板所能使用的最高频率内存，吞吐量和性能越高
- 内存的越大，足够的可将大量随机I/O转成顺序I/O，用缓存把多次写变成一次写

**3. I/O子系统**

​	PCIe→SSD→RAID 10→机械磁盘→SAN

#### 2.1.4 操作系统对性能的影响

​	MySQL适合的操作系统：Windows、FreeBSD、Solaris、Linux。

**1. CentOS系统参数优化：**

​	**内核相关参数（/etc/sysctl.conf）**

​	网络相关参数：

````java
net.core.somaxconn=65535 // 每个端口最大监听长度,一般修改为2048+
net.core.netdev_max_backlog=65535 // 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目
net.ipv4.tcp_max_syn_backlog=65335 // 表示那些尚未收到客户端确认信息的连接（SYN消息）队列的长度，默认为1024，加大队列长度为65335，可以容纳更多等待连接的网络连接数
````

​	控制TCP处理参数：

````java
net.ipv4.tcp_fin_timeout=10 // tcp连接的等待状态的时间间隔，默认60s，缩短一点加快tcp的回收速度
net.ipv4.tcp_tw_reuse=1 // 表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接
net.ipv4.tcp_tw_recycle=1 // 开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭
````

​	TCP缓冲区参数：

````java
net.core.wmem_default=87380 // 发送套接字缓冲区大小的默认值(字节)
net.core.wmem_max=16777216 	// 发送套接字缓冲区大小的最大值(字节)
net.core.rmem_default=87380 // 接收套接字缓冲区大小的默认值(字节)
net.core.rmem_max=16777216 	// 接收套接字缓冲区大小的最大值(字节)
````

​	TCP长连接参数：

````java
net.ipv4.tcp_keepalive_time=120	// 当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为2分钟
net.ipv4.tcp_keepalive_intvl=30 // 发送消息未获得响应时重发消息的时间间隔（s）
net.ipv4.tcp_keepalive_probes=3	// TCP连接失效前最多发送3个keepalive消息。
````

​	内存相关参数：

````java
kernel.shmmax=4294967295	// 定义单个共享内存段的最大值，
````

​	※注意：

- 参数应设置的足够大，以便能在一个共享内存段下容纳下整个Innodb缓冲池的大小
- 这个值的大小对于64位linux系统，可取的最大值为物理内存值 - 1 byte，建议值为大于物理内存的一半，一般取值大于Innodb缓冲池的大小即可，可以取物理内存 - 1 byte。

````java
vm.swappiness=0		// 当内存不足时会对性能产生比较明显的影响，linux内核除非虚拟内存完全满了，否则不使用交换区
````

​	**增加资源限制（/etc/security/limit.conf）**

​	这个文件是Linx PAM（插入式认证模块）的配置文件，配置**打开文件数的限制**。

````java
* soft nofile 65535
* hard nofile 65535
````

​	加到文件末尾即可，修改此文件需要重启系统才能生效。

- *表示对所有用户有效
- soft表示当前系统生效的设置
- hard表示系统中所能设定的最大值
- nofile表示所限制的资源是打开文件的最大数目
- 65535表示限制的文件数

​	**磁盘调度策略（/sys/block/devname/queue/scheduler）**

​	执行下面的命令：

````
cat /sys/block/devname/queue/scheduler
noop anticipatory deadline [cfq]
````

​	noop（电梯式调度策略）：NOOP实现了一个FIFO队列，它像电梯的工作方法一样对I/O请求进行组织，当有一个新的请求到来时，它将请求合并到最近的请求之后，以此来保证请求同一介质。NOOP倾向于饿死读而利于写，因此NOOP对于*闪存设备、RAM及嵌入式系统*是最好的选择。

​	deadline（截止时间调度策略）：Deadline确保了在一个截止时间内服务请求，这个截止时间是可调整的，而默认读期限短于写期限。这样便防止了写操作因为不能被读取而饿死的现象，Deadline对数据库类应用是最好的选择。

​	anticipatory（预料I/O调度策略）：本质上与Deadline一样，但在最后一次读操作后，要等待6ms，才能继续进行对其他I/O请求进行调度。它会在每个6ms中插入新的I/O操作，而会将一些小写入流合并成一个大写入流，用写入延时换取最大的写入吞吐量。它适合于*写入较多的环境*，比如文件服务器，对于数据库环境表现很差。

​	**EXT3/4系统的挂载参数（/etc/fstab）**

	dada=writeback|ordered|journal
	noatime,nodiratime

- writeback 意味着只有原数据写入日志，原数据写入和数据写入并不是同步的，这是最快的一种配置，因为Innodb有自己的事务日志，所以选择Innodb是最好的选择。
- ordered选项只会记录原数据，但提供了一些一致性的保证，在写原数据之前的会先写数据，使他们保持一致，这个选项比writeback 慢一些，但是如果出现崩溃呢更加安全。
- journal提供了原子日志的一种行为，在数据写入到最终位置之前，将记录到日志中，这个选项对Innodb来说是没有必要的，在这三个选项中最慢的一个
- noatime，nodiratime，用于禁止记录文件的访问时间和读取目录的时间，禁用了这两个时间的选项后，可以减少一些，写的操作。

​	执行下方命令：

````yml
## 禁止记录文件的访问时间和读取数据库的时间，提高服务器性能
/dev/sda1/ext4 noatime,nodiratime,data=writeback 1 1
````

​	Windows包含FAT和NTFS两种文件系统，但是只有NTFS文件系统能作为服务器使用。

​	Linux包含EXT3、EXT4和XFS等文件系统，XFS文件系统更适合MySQL服务器使用。

#### 2.1.5 存储引擎对性能的影响

​	常用的存储引擎有：Innodb、MyISAM、XtraDB、CSV、Memory、MRG_MYISAM、archive（不支持UPDATE和DELETE语句）、federated和tokudb等。

​	**※注意：存储引擎是针对表的而不是针对库的。（一个库中的不同表可以使用不同的存储引擎，一般不建议这样做）。**

​	MySQL 5.5 之前默认使用MyISAM存储引擎，MySQL 5.5 之后默认Innodb。

**1. MyISAM存储引擎**

​	**特性**

- 并发性与锁级别（表级锁，对表数据时进行写操作时对整个表加锁，对表数据进行读操作时加共享锁，共享锁之间不会阻塞，读快，读写混合慢）
- 表损坏修复（命令：`check table TABLENAME` 和 `repair table TABLENAME`）
- 支持的索引类型（全文索引，text、blob类型前500字符的前缀索引）
- 支持数据压缩（压缩后无法修改表数据，命令`myisampack -b -f 文件名.MYI`）

​	**限制**

- 版本< MySQL 5.0时默认表大小为4G（若存储大表则要修改 MAX_Rows和AVG_ROW_LENGTH两个参数，修改后会表的重建）
- 版本> MySQL 5.0时默认表大小为256TB

​	**适用场景**

- 非事务型应用
- 只读类应用
- 空间类应用（如GPS数据）

**2. Innodb存储引擎**

​	**特性**

- Innodb是一种事务性存储引擎
- 完全支持事务的ACID特性（四大特性）
- Redo Log 和 Undo Log（Undo 记录某 **数据** 被修改 **前** 的值，可以用来在事务失败时进行 rollback；
	Redo 记录某 **数据块** 被修改 **后** 的值，可以用来恢复未写入 data file 的已成功事务更新的数据）
- Innodb支持行级锁，行级锁可以最大程度的支持并发，行级锁由存储引擎层实现的

​	**适用场景**

- Innodb适合于大多数OLTP应用（MySQL 5.7后Innodb支持**全文索引**和**空间函数**）

> Innodb使用表空间进行存储。
>
> innodb_file_per_table参数开关作用：

- ON表示独立表空间：tablename.ibd
- OFF表示系统表空间：ibdataX

> 系统表空间和独立表空间的区别：

- 系统表空间无法简单的收缩文件大小（当磁盘空间不足时删除数据不会减少系统表的文件大小）
- 独立表空间可以通过`optimize table`命令收缩系统文件
- 系统表空间会产生IO瓶颈
- 独立表空间可以同时向多个文件刷新数据

> 建议对Innodb使用独立表空间。

​	存在于系统表空间的标转移到独立表空间步骤：

​	（1）使用mysqldump导出所有数据库表数据

​	（2）停止MySQL服务，修改参数，并删除Innodb相关文件

​	（3）重启MySQL服务，重建Innodb系统表空间

​	（4）重新导入数据

**3. CSV存储引擎**

​	**文件系统存储特点**

​	数据以文本方式存储在文件中

- *.CSV文件存储表内容
- *.CSM文件存储表的元数据（如表状态和数据量）
- *.frm文件存储表结构信息

​	**特点**

- 以CSV格式进行数据存储
- 所有列都不能为NULL
- 不支持索引，不适合大表，不适合在线处理
- 支持对数据文件直接编辑，保存文本文件内容

​	**使用场景**

- 适合作为数据交换的中间表

**4. Archive存储引擎**

​	**文件系统存储特点**

- 以zlib对表数据进行压缩，磁盘I/O更少
- 数据存储在ARZ为后缀的文件中

​	**特点**

- 只支持insert和select操作
- 只允许在自增ID列上加索引

​	**适用场景**

- 日志和数据采集类应用

**5. Memory存储引擎**

​	又称为HEAP存储引擎，Memory存储引擎数据易丢失，所以要求数据可再生的，但是表结构是持久性的。

​	**文件系统存储特点**

- 数据保存在内存中

​	**特点**

- 支持Hash索引和BTree索引（默认使用Hash索引，等值查找用Hash索引，范围查找用BTree索引）
- 所有字段都为固定长度（varchar(10) 相当于char(10)）
- 不支持bolg和text等类型
- Memory使用表级锁
- 存储引擎最大大小由max_heap_table_size参数决定（默认大小为16MB）

​	**适用场景**

- 用于查找或者是映射表（例如邮编和地区的对应表）
- 用于保存数据分析中产生的中间表
- 用户缓存周期性聚合数据的结果表

**6. Federated存储引擎**

​	**特点**

- 提供了访问远程MySQL服务器上表的方法
- 本地不存储数据，数据全部放到远程服务器上
- 本地需要保存表结构和远程服务器的连接信息

​	**如何使用**

​	默认禁止，启用需要在mysql配置文件里增加参数`fedetated=1`，连接远程服务器需要在语句后加上：

````yml
## 例子：
## connection='mysql://root:123@127.0.0.1:3306/ichat/tb_user'
connection='mysql://user_name[:password]@host_name[:port_num]/db_name/tbl_name'
````

​	**适用场景**

- 偶尔的统计分析及手工查询

#### 2.1.6 如何选择正确的存储引擎

**参考条件**

- 事务
- 备份
- 崩溃恢复
- 存储引擎的特有特性

### 2.2 MySQL服务器参数

**1. MySQL获取配置信息路径**

- 命令行参数

	````
	mysqld_safe --datadir=/data/sql_data
	````

- 配置文件

	````
	mysql --help --verbose|grep -A 1 'Default options'
	/etc/my.cnf /etc/mysql/my.cnf /home/mysql/my.cnf
	~/.my.cnf
	````

**2. MySQL配置参数的作用域**

- 全局参数

	````xml
	set global 参数名=参数值;
	set @@global.参数名:=参数值;
	````

- 会话参数

	````
	set [session] 参数名=参数值;
	set @@session.参数名:=参数值;
	````

**3. 内存配置相关参数**

- 确定可以使用的内存上限
- 确定MySQL的每个连接使用的内存（`sort_buffer_size` 排序缓冲区大小；`join_buffer_size` 连接冲区大小；`read_buffer_size` 读缓冲区大小，**大小必须为4k的倍数**；`read_buffer_size` 索引缓冲区大小；**谨慎配置这4个参数**）
- 确定需要为操作系统保留多少内存
- 为缓冲池分配内存（`Innodb_buffer_pool_size`，计算方式为：总内存 - (每个线程需要的内存 * 连接数) - 系统保留内存，且它的大小要在服务器内存的75%以上；`key_buffer_size`，主要是用于MyISAM的索引缓存，查询索引缓存语句：`select sum(index_length) from information_schema.tables where engine='myisam'`）

**4. I/O相关配置参数**

​		**Innodb I/O相关配置**

- `Innodb_log_file_size` （控制单个事务日志大小，**控制事务日志总大小改单个事务日志大小即可，不需要改文件数**）

- `Innodb_log_file_in_group` （控制事务日志的文件数）

- 事务日志总大小=`Innodb_log_file_size`*`Innodb_log_file_in_group`

- `Innodb_log_buffer_size` （控制事务日志缓冲区的大小，32MB~128MB）

- `Innodb_flush_log_at_trx_commit` （控制刷新事务日志的频率）

	0：每秒进行一次log写入cache，并flush log到磁盘（进程崩溃会丢失一秒内的log）

	1[默认]：每次事务提交执行log写入cache，并flush log到磁盘（安全性最高，并发低）

	2[建议]：每次事务提交，执行log数据写入到cache，每秒执行一次flush log到磁盘（宕机时才会丢失一秒内的log）

- `Innodb_flush_method=O_DIRECT` （Innodb刷新方式=不写入缓存直接写入磁盘，适合linux）

- `Innodb_file_per_table=1` （控制Innodb为每个表建立单独表空间，**建议设置为1，启用**）

- `Innodb_doublewrite=1`（双写缓存，**建议设置为1，启用**，增加数据安全性）

​		**MyISAM I/O相关配置**

- `delay_key_write` （控制关键字中的缓冲脏块刷新到磁盘的频率）

	OFF：每次写操作后刷新缓冲中的脏块到磁盘

	ON：只对建表时指定了`delay_key_write`选项的表使用延迟刷新

	ALL：对多有MyISAM表都使用延迟键写入（服务器宕机后需要对索引进行修复操作）

**5. 安全相关配置参数**

- `expire_logs_days` 指定自动清理binlog的天数

- `max_allowed_packet` 控制MySQL可以接收的包的大小（**主从配置必须一致**）

- `skip_name_resolve` 禁用DNS查找（**强烈建议开启这个配置**，但是授权就只能从ip段中进行设置了）

- `sysdate_is_now` 确保`sysdate()`返回确定性日期

- `read_only` 禁止非super权限的用户写权限（在从库中启用，则只接受从主库中传来的数据，启用前必须授予主库super权限）

- `skip_slave_start` 禁用Slave自动恢复（从库重启后自动进行复制，安全性较低，建议启用它，关闭自动恢复功能）

- `sql_mode` 设置MySQL所使用的SQL模式（**生产环境禁止改动**）

	`strict_trans_tables` （指定事务不能插入到事务存储引擎中，则会中断当前操作，对非事务存储引擎无影响）

	`no_engine_subtitution` （建表时指定存储引擎不可用的情况下，建表则会失败，并不会直接使用默认存储引擎建表）

	`no_zero_date` （不会把0年0月0日这样的日期写入到表中）

	`no_zero_in_date` （不会把部分带有0年、0月或者0日这些不合法日期写入到表中）

	`only_full_group_by` （在分组查询中把所有没有集合函数的列都列出来，否则无法执行sql语句）

**6. 其他常用配置参数**

- `sync_binlog` （控制MySQL如何向磁盘刷新binlog）
- `tmp_table_size` 和 `max_heap_table_size`控制内存临时表大小（**主从服务器必须保持一致**）
- `max_connections` （控制允许的最大连接数，默认100，一般设置更大）

### 2.3 数据库设计对性能的影响

​	**数据库的设计对性能的影响是最大的，当数据库设计优化到无法更进一步的时候再去考虑优化服务器参数方面。**

​	**影响性能的几个方面**

- 过分的反范式化，为表建立太多的列（会消耗过多CPU资源）
- 过分的范式化，造成太多的表关联
- 在OLTP环境中使用了不恰当的分区表
- 使用外键约束保证数据的完整性

​	**性能优化顺序**

​	（1）数据库结构设计和SQL语句

​	（2）数据库存储引擎的选择和参数配置

​	（3）系统选择及优化

​	（4）硬件升级

## 第三章 MySQL基准测试

### 3.1 基准测试定义：

​	基准测试是一种测量和评估软件性能指标的活动，用于简历某个时刻的性能基准，以便当系统发生软硬件变化时重新进行基准测试以评估变化对性能的影响。

​	基准测试是针对系统设置的一种压力测试。

### 3.2 基准测试与压力测试的区别：

- 基准测试比较直接、简单、易于比较，用于评估服务器的处理能力
- 压力测试是对真实的业务数据进行测试，获得真实系统所能承受的压力
- 基准测试不关心业务逻辑，所使用的查询和业务的真实性以及业务环境没有关系
- 压力测试需要针对不同的主题，所使用的数据和查询也是真实用到的

### 3.3 基准测试目的：

- 建立MySQL服务器的性能基准线
- 模拟比当前系统更高的负载，以找出系统的扩展瓶颈，增加数据库并发，观察QPS，TPS变化，确定并发量与性能最优的关系
- 测试不同的硬件、软件和操作系统配置
- 证明新的硬件设备是否配置正确

### 3.4 基准测试方法：

​	**1. 对整个系统进行基准测试**

​	从系统入口进行测试（如网站Web前端，手机APP前端）。

​	优点：

- 能够测试整个系统的性能，包括web服务器缓存、数据库等
- 能反映出系统中各个组件接口间的性能问题，体现真实性能状况

​	缺点：

- 测试设计复杂，消耗时间长

​	**2. 单独对MySQL进行基准测试**

​	优点：

- 测试设计简单，所耗费时间短

​	缺点：

- 无法全面了解整个系统的性能基线

​	**3. MySQL基准测试的常见指标**

- 单位时间内所处理的事务数（TPS）
- 单位时间内所处理的查询数（QPS）
- 响应时间：平均响应时间、最小响应时间、最大响应时间、各时间所占百分比
- 并发量：同时处理的查询请求的数量（**并发量不等于连接数**，即正在工作中的并发的操作数或同时工作的数量）

​	**4. 基准测试的步骤**

​	计划和设计基准测试

​	（1）决定好对整个系统还是某一组件，以及使用什么样的数据来测试。

​	（2）准备基准测试及数据收集脚本（CPU使用率、IO、网络流量、状态和计数器信息等）

​	数据收集脚本文件（命名为xxx.sh）

````shell
##!/bin/bash
INTERVAL=5
PREFIX=/home/testinfo/benchmarks/$INTERVAL-sec-status
RUNFILE=/home/testinfo/benchmarks/running
echo "1" > $RUNFILE
MYSQL=/usr/local/mysql/bin/mysql
$MYSQL -e "show global variables" >> mysql-variables
while test -e $RUNFILE; do
	file=$(date +%F_%I)
	sleep=$(date +%s.%N | awk '{print 5 - ($1 % 5)}')
	sleep $sleep
	ts="$(date +"TS %s.%N %F %T")"
	loadavg="$(uptime)"
	echo "$ts $loadavg" >> $PREFIX-${file}-status
	$MYSQL -e "show global status" >> $PREFIX-${file}-status &
	echo "$ts $loadavg" >> $PREFIX-${file}-innodbstatus
	$MYSQL -e "show engine innodb status" >> $PREFIX-${file}-innodbstatus &
	echo "$ts $loadavg" >> $PREFIX-${file}-processlist
	$MYSQL -e "show full processlist\G" >> $PREFIX-${file}-processlist &
	echo $ts
done
echo Exiting because $RUNFILE does not exists
````

​	（3）运行基准测试

​	（4）保存及分析基准测试结果

​	保存及分析结果脚本文件（命名为xxx.sh）

````shell
##!/bin/bash
awk '
   BEGIN {
     printf "##ts date time load QPS";
     fmt=" %.2f";
   }
   /^TS/ {
   ts = substr($2,1,index($2,".")-1);
   load = NF -2;
   diff = ts - prev_ts;
   printf "\n%s %s %s %s",ts,$3,$4,substr($load,1,length($load)-1);
   prev_ts=ts;
   }
   /Queries/{
   printf fmt,($2-Queries)/diff;
   Queries=$2
   }
   ' "$@"
````

​	**5. 基准测试容易忽略的问题**

- 使用生产环境数据时只是用了部分数据（应使用数据库的完整备份进行测试）
- 在多用户场景中，只做单用户的测试（应使用多线程并发测试）
- 在单服务器上测试分布式应用（应使用相同架构环境测试）
- 反复执行同一查询（容易缓存命中，无法反映真实查询性能）

### 3.5 常用基准测试用具

​	**1. mysqlslap**

​	MySQL服务器自带的基准测试工具。

​	特点：

- 可以模拟服务器负载，并输出相关统计信息
- 可以指定或自动生成查询语句

​	命令常用参数（多参数逗号分隔）：

- `--auto-generate-sql` 由系统自动生成SQL脚本进行测试
- `--auto-generate-sql-add-autoincrement` 在生成的表中增加自增ID
- `--auto-generate-sql-load-type` 指定测试中使用的查询类型
- `--auto-generate-sql-write-number` 指定初始化数据时生成的数据量
- `--concurrency` 指定并发线程的数量
- `--engine` 指定要测试表的存储引擎
- `--no-drop` 指定不清理测试数据
- `--iterations` 指定测试运行的次数
- `--number-of-queries` 指定每一个线程执行的查询数量
- `debug-info` 指定输出额外的内存及CPU统计信息
- `--number-int-cols` 指定测试表中包含的 INT 类型列的数量
- `--number-char-cols` 指定测试表中包含的 varchar 类型的数量
- `--create-schema` 指定了用于执行测试的数据库的名字
- `--query` 指定自定义 SQL 的脚本
- `--only-print` 不运行测试脚本，只是把生成的脚本打印出来 

`````shell
mysqlslap --concurrency=1,50 --iterations=3 --number-int-cols=5 --number-char-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement --engine=myisam,innodb --number-of-queries=10 --create-schema=sbtest
`````

​	测试结果如下：

![image-20200221225143340](assets/image-20200221225143340.png)

​	**2. sysbench**



## 第四章 数据库优化

### 4.1 数据库结构优化

​	**1. 目的**

- 减少数据冗余
- 尽量避免数据维护中出现更新，插入和删除异常
  - 插入异常：表中某个实体随着另一个实体而存在（即外键）
  - 更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新
  - 删除异常：如果删除表中的某一实体则会导致其他实体的消失

- 节约数据存储空间
- 提高查询效率

​	**2. 数据库结构设计的步骤**

​		①需求分析：全面了解产品设计的存储需求

​		②逻辑设计：设计数据的逻辑存储结构

​		③物理设计：根据所使用的数据库特点进行表结构设计

​		④维护优化：根据试剂情况对索引、存储结构等进行优化

​	**3. 数据库设计范式**

​		概念：

- 第一范式：①数据库表中的所有字段斗只具有单一属性；②单一属性的列是由基本的数据类型所构成的；③设计出来的表都是简单的二维表
- 第二范式：要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列支队
- 第三范式：每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖

​		优点：

- 可以尽量的减少数据冗余（数据表更新快体积小）
- 范式化的更新操作比反范式化更快
- 范式化的表通常比反范式化更小

​	**4. 反范式化设计**

​		指为了性能和读取效率的考虑而适当的违反对数据库设计范式的要求，允许存在少量的数据冗余，本质上来看反范式化就是使用空间来换取时间。

​		优点：

- 可减少表的关联
- 可更好的进行索引优化

​		缺点：

- 存在数据冗余及数据维护异常
- 对数据的修改需要更多的成本

### 4.2 物理设计

#### 4.2.1 命名规范

​	定义数据库、表及字段的命名规范：

- 可读性命名原则
- 表意性命名原则
- 长名命名原则

#### 4.2.2 选择合适的存储引擎

​	选择合适的存储引擎（存储引擎对比图如下）

![image-20200227223241321](assets/image-20200227223241321.png)

#### 4.2.3 选择合适的数据类型

​	为表中的字段选择合适的数据类型。

​	当一个列可选多种数据类型时，优先选择数字类型，其次是日期或二进制类型，最后是字符类型。（对于同级别的数据类型，优先选择占用空间小的数据类型）

​	①整数类型对比图如下

![image-20200227224039639](assets/image-20200227224039639.png)

​	②实数类型对比图如下

![image-20200227224651629](assets/image-20200227224651629.png)

​	③VARCHAR类型和CHAR类型对比

- VARCHAR类型的存储特点:
  - 用于存储变长字符串，只占用必要的存储空间**（单位是字符而不是字节）**
  - 列的最大长度小于255则只占用一个额外字节用于记录字符串长度，大于则占用2个额外字节
- VARCHAR类型的适用场景：
  - 字符串列的最大长度比平均长度大很多
  - 字符串列很少被更新
  - 使用了多字节字符集存储字符串
- CHAR类型的存储特点：
  - CHAR类型是定长的
  - 字符串存储在CHAR类型的列中会删除末尾的空格
  - CHAR类型的最大宽度为255
- CHAR类型的适用场景：
  - CHAR类型适合存储长度近似的值
  - CHAR类型适合存储短字符串
  - CHAR类型适合存储经常更新的字符串列

​	④日期类型对比

- datetime类型
  - 以 `YYYY-MM-DD HH:MM:SS[.fraction]` 格式存储日期时间
  - datetime类型与时区无关，占用8个字节的存储空间（占用空间较大）
  - 时间范围 `1000-01-01 00:00:00` 到 `9999-12-31 23:59:59` 
- timestamp类型
  - 显示依赖于所指定的时区
  - 在行的数据修改时可以自动修改timestamp列的值
  - 时间范围 `1970-01-01` 到 `2038-01-19`
- date类型和time类型
  - date类型
    - 占用的字节数比使用字符串、datetime（8个字节）、int（4个字节）存储要少，只需3个字节
    - 使用date类型还可以利用日期时间函数进行日期之间的计算
    - 时间范围 `1000-01-01` 到 `9999-12-31`
  - time类型
    - 用于存储时间数据，格式为 `HH:MM:SS`
- ※注意事项
  - 不要使用字符串类型存储日期时间数据
    - 日期时间类型一般比字符串占用的存储空间小
    - 日期时间类型在查找过滤时可以利用日期来对比
    - 日期时间类型有丰富的处理函数，很方便对日期时间进行计算
  - 使用int类型存储日期时间不如使用timestamp类型（存储毫秒时间戳时int类型还会溢出）

#### 4.2.4 为Innodb选择合适主键

- 主键应尽可能的小
- 主键应是顺序增长的（增加数据的插入效率）
- Innodb的主键和业务主键可以不同

## 第五章 数据库架构设计

### 5.1 MySQL主从复制

​	**1. 解决的问题**

- 实现在不同服务器上的数据分布（利用二进制日志增量进行，无需太多带宽，但是使用基于行的复制在进行大批量的更改时会对带宽带来一定压力，尤其是跨IDC环境吓进行复制，所以应该分批进行）
- 实现数据读取的负载均衡（需要其他组件配合完成，①如利用DNS轮询的方式把程序的读连接到不同的备份库，②使用LVS，haproxy这样的代理方式，③非共享架构，同样的数据分布在多台服务器上）
- 增强了数据的安全性（利用备库的备份来减少主库负载，但是复制不能代替备份）
- 实现数据库高可用和故障切换（方便进行数据高可用架构的部署，避免MySQL单点失败）
- 实现数据库在线升级



​	**2. MySQL二进制日志**

​	MySQL日志分类图如下：

![1583159870844](assets/1583159870844.png)

​	①二进制日志的格式

- 基于段的格式 `binlog_format=STATEMENT`
  - 优点：日志记录量相对较小，节约磁盘及网络I/O（原因：只对一条记录修改或插入，row格式所产生的日志量小于段产生的日志量）
  - 缺点：可能造成MySQL复制的主备服务器数据不一致（原因：①必须要记录上下文信息，保证语句在从服务器上执行结果和在主服务器上相同；②特定的函数如`UUID()` 和 `user()` 这样非确定性函数还是无法复制）