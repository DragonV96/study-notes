# 项目性能调优

## 1 性能调优概念

### 1.1 调优原因及目的

**1. 原因**

没有经过性能测试的系统，访问量急剧上升时，会导致系统不稳定甚至宕机。

**2. 目的**

- 提高系统性能；
- 节省公司成本。

### 1.2 调优时机

**1. 项目开发初期**

代码层面保证规范的编码：

- 减少磁盘 I/O 操作；
- 降低竞争锁的使用
- 使用低复杂度算法；
- 合理使用设计模式实现业务代码（如商品折扣红包等业务使用装饰模式）。

**2. 项目开发完成**

- 根据性能测试结果种的不足指标定向调优；
- 对日志进行分析及时修复问题。

### 1.3 调优指标

**1. CPU**

减少 CPU 占用过高的操作，占用 CPU 资源的操作：

- 代码递归导致的无限循环
- 正则表达式引起的回溯
- JVM 频繁的 Full GC
- 多线程编程造成的大量上下文切换

**2. 内存**

内存成本较高，在有限的内存中，降低内存溢出、内存泄漏等风险。

**3. 磁盘 I/O**

磁盘 I/O 读写速度较慢，尽量减少磁盘 I/O 访问次数。

**4. 网络**

提高网络带宽大小。

**5. 异常**

Java 项目中，抛出异常需要构建异常栈，对异常进行捕获和处理，此过程非常消耗系统性能。

**6. 数据库**

大量写操作的系统，优化数据库是整个系统的核心工作。

**7. 锁竞争**

减少锁竞争带来的上下文切换，降低系统性能消耗。

**8. 响应时间 RT**

响应时间（Response Time）越短越好，分为四种：

- 数据库响应时间（最耗时）：主要是写入数据到磁盘的时间消耗；
- 服务端响应时间（包含 Nginx 转发请求时间）：主要是服务端业务逻辑的时间消耗；
- 网络响应时间：主要是对传输请求及响应进行解析的时间消耗；
- 客户端响应时间：客户端含有大量逻辑处理的时间消耗（几乎没有逻辑处理的 Web、APP 客户端时间消耗可忽略不计）。

**9. 吞吐量 TPS**

吞吐量（Transaction per second）越高越好，即每秒事务处理，可分为两种：

- 磁盘吞吐量
- 网络吞吐量

1）磁盘吞吐量

磁盘吞吐量有两个关键指标：

- IOPS（Input/Output Per Second），即每秒的读写次数，主要是随机读写的场景，如小文件存储、OLTP 数据库、邮件服务器等；
- 数据吞吐量，即单位时间内可以成功传输的数据量，主要是顺序读写的场景，如电视台的视频编辑、音频/视频点播等。

2）网络吞吐量 

网络吞吐量指在不丢帧的情况下，设备能够接受的最大数据速率，影响因素如下：

- CPU
- 网卡处理能力
- 网络带宽大小
- 防火墙
- 外部接口响应时间 RT
- 磁盘 I/O

**10. 计算机资源分配使用率**

计算机资源分配使用率就像木桶效应，最高性能取决于木桶中的最短短板，有4个指标：

- CPU 占用率
- 内存使用率
- 磁盘 I/O
- 网络 I/O

**11. 负载承受能力**

负载承受能力有两个指标：

- 系统压力上升时，系统响应时间曲线变化是否平缓；
- 系统压力的上限（压力增长到系统大量抛出错误时）。

### 1.4 微基准性能测试

**1. 目标**

精准定位到某个模块或方法的性能问题。

**2. 适用场景**

适用于做一个功能模块或一个方法在不同实现方式下的性能对比，如方法加锁和不加锁的性能对比。

### 1.5 宏基准性能测试

**1. 测试环境**

需要模拟线上真实环境，包括部署方案、真实数据等。

**2. 测试场景**

测试接口时需要排除其他业务接口的干扰。

**3. 测试目标**

- 吞吐量、响应时间是否达标
- 观察最大 TPS 时各个服务器的 CPU、内存及 I/O 使用率的变化

**4. 干扰因素**

- 热身问题
- 性能测试结果不稳定
- 多 JVM 情况下的影响

1）热身问题

- 问题状况：性能测试时，系统运行的越来越快，同一接口或方法的运行速度比第一次访问快上几倍；
- 产生原因：①随着某个方法或代码块的执行次数增多，JVM 会通过即时编译器（JIT compiler，just-in-time compiler）对程序中的热点代码编译成平台相关机器码，并进行各层次的优化，并存储在内存中；②刚开始的运行阶段，JVM 会花费很长时间来全面优化代码，后续则以最高性能执行。

2）性能测试结果不稳定

- 问题状况：每次测试所用数据集都是相同的，但是测试结果确有差异；
- 产生原因：①其他进程的影响；②网络波动；③每个阶段的 JVM 垃圾回收内存分配效率的不同。

3）多 JVM 情况下的影响

- 问题状况：多个 Java 应用部署在不同的 tomcat 下，其中任意一个 JVM 都拥有整个系统的资源使用权，互相争夺抢占资源；
- 解决方案：尽量避免线上环境中一台机器部署多个 JVM 的情况。

### 1.6 调优策略

从应用层到操作系统层的几种调优策略：

- 优化代码
- 优化设计
- 优化算法
- 时间换空间
- 空间换时间
- 参数调优
- 兜底策略，确保系统稳定性

**1. 优化代码**

- 避免内存溢出等问题代码
- 优化非问题代码，如使用合适场景的集合类

**2. 优化设计**

使用合适的设计模式。

**3. 优化算法**

使用较低的时间复杂度的算法。

**4. 时间换空间**

系统对时间的要求比空间重要的场景，如 String 的 `intern()` 方法，将重复率较高的数据集存储在常量池，节省空间。

**5. 空间换时间**

系统对空间的要求比时间重要的场景，提升系统访问速度，如分库分表。

**6. 参数调优**

可进行参数调优的层面：

- JVM（内存空间及垃圾回收算法）
- Web 容器（线程池的设置）
- 操作系统（内核参数设置）

**7. 兜底策略**

系统优化的再好也有承受极限，为保证系统稳定性，必须提供兜底策略：

- 限流（达到最大范围采取熔断，返回友好提示，而不是崩溃信息）
- 实现智能横向扩容（超过指定请求阈值时，系统根据需求自动横向扩容，如 Kubernetes）
- 提前扩容（适用于秒杀、抢购等高并发系统）

## 2 代码性能调优





## 3 多线程性能调优

## 4 JVM 性能调优

## 5 代码设计模式优化

## 6 MySQL 调优























