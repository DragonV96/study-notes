# 项目性能调优

## 1 性能调优概念

### 1.1 调优原因及目的

**1. 原因**

没有经过性能测试的系统，访问量急剧上升时，会导致系统不稳定甚至宕机。

**2. 目的**

- 提高系统性能；
- 节省公司成本。

### 1.2 调优时机

**1. 项目开发初期**

代码层面保证规范的编码：

- 减少磁盘 I/O 操作；
- 降低竞争锁的使用
- 使用低复杂度算法；
- 合理使用设计模式实现业务代码（如商品折扣红包等业务使用装饰模式）。

**2. 项目开发完成**

- 根据性能测试结果种的不足指标定向调优；
- 对日志进行分析及时修复问题。

### 1.3 调优指标

**1. CPU**

减少 CPU 占用过高的操作，占用 CPU 资源的操作：

- 代码递归导致的无限循环
- 正则表达式引起的回溯
- JVM 频繁的 Full GC
- 多线程编程造成的大量上下文切换

**2. 内存**

内存成本较高，在有限的内存中，降低内存溢出、内存泄漏等风险。

**3. 磁盘 I/O**

磁盘 I/O 读写速度较慢，尽量减少磁盘 I/O 访问次数。

**4. 网络**

提高网络带宽大小。

**5. 异常**

Java 项目中，抛出异常需要构建异常栈，对异常进行捕获和处理，此过程非常消耗系统性能。

**6. 数据库**

大量写操作的系统，优化数据库是整个系统的核心工作。

**7. 锁竞争**

减少锁竞争带来的上下文切换，降低系统性能消耗。

**8. 响应时间 RT**

响应时间（Response Time）越短越好，分为四种：

- 数据库响应时间（最耗时）：主要是写入数据到磁盘的时间消耗；
- 服务端响应时间（包含 Nginx 转发请求时间）：主要是服务端业务逻辑的时间消耗；
- 网络响应时间：主要是对传输请求及响应进行解析的时间消耗；
- 客户端响应时间：客户端含有大量逻辑处理的时间消耗（几乎没有逻辑处理的 Web、APP 客户端时间消耗可忽略不计）。

**9. 吞吐量 TPS**

吞吐量（Transaction per second）越高越好，即每秒事务处理，可分为两种：

- 磁盘吞吐量
- 网络吞吐量

1）磁盘吞吐量

磁盘吞吐量有两个关键指标：

- IOPS（Input/Output Per Second），即每秒的读写次数，主要是随机读写的场景，如小文件存储、OLTP 数据库、邮件服务器等；
- 数据吞吐量，即单位时间内可以成功传输的数据量，主要是顺序读写的场景，如电视台的视频编辑、音频/视频点播等。

2）网络吞吐量 

网络吞吐量指在不丢帧的情况下，设备能够接受的最大数据速率，影响因素如下：

- CPU
- 网卡处理能力
- 网络带宽大小
- 防火墙
- 外部接口响应时间 RT
- 磁盘 I/O

**10. 计算机资源分配使用率**

计算机资源分配使用率就像木桶效应，最高性能取决于木桶中的最短短板，有4个指标：

- CPU 占用率
- 内存使用率
- 磁盘 I/O
- 网络 I/O

**11. 负载承受能力**

负载承受能力有两个指标：

- 系统压力上升时，系统响应时间曲线变化是否平缓；
- 系统压力的上限（压力增长到系统大量抛出错误时）。

### 1.4 微基准性能测试

**1. 目标**

精准定位到某个模块或方法的性能问题。

**2. 适用场景**

适用于做一个功能模块或一个方法在不同实现方式下的性能对比，如方法加锁和不加锁的性能对比。

### 1.5 宏基准性能测试

**1. 测试环境**

需要模拟线上真实环境，包括部署方案、真实数据等。

**2. 测试场景**

测试接口时需要排除其他业务接口的干扰。

**3. 测试目标**

- 吞吐量、响应时间是否达标
- 观察最大 TPS 时各个服务器的 CPU、内存及 I/O 使用率的变化

**4. 干扰因素**

- 热身问题
- 性能测试结果不稳定
- 多 JVM 情况下的影响

1）热身问题

- 问题状况：性能测试时，系统运行的越来越快，同一接口或方法的运行速度比第一次访问快上几倍；
- 产生原因：①随着某个方法或代码块的执行次数增多，JVM 会通过即时编译器（JIT compiler，just-in-time compiler）对程序中的热点代码编译成平台相关机器码，并进行各层次的优化，并存储在内存中；②刚开始的运行阶段，JVM 会花费很长时间来全面优化代码，后续则以最高性能执行。

2）性能测试结果不稳定

- 问题状况：每次测试所用数据集都是相同的，但是测试结果确有差异；
- 产生原因：①其他进程的影响；②网络波动；③每个阶段的 JVM 垃圾回收内存分配效率的不同。

3）多 JVM 情况下的影响

- 问题状况：多个 Java 应用部署在不同的 tomcat 下，其中任意一个 JVM 都拥有整个系统的资源使用权，互相争夺抢占资源；
- 解决方案：尽量避免线上环境中一台机器部署多个 JVM 的情况。

### 1.6 调优策略

从应用层到操作系统层的几种调优策略：

- 优化代码
- 优化设计
- 优化算法
- 时间换空间
- 空间换时间
- 参数调优
- 兜底策略，确保系统稳定性

**1. 优化代码**

- 避免内存溢出等问题代码
- 优化非问题代码，如使用合适场景的集合类

**2. 优化设计**

使用合适的设计模式。

**3. 优化算法**

使用较低的时间复杂度的算法。

**4. 时间换空间**

系统对时间的要求比空间重要的场景，如 String 的 `intern()` 方法，将重复率较高的数据集存储在常量池，节省空间。

**5. 空间换时间**

系统对空间的要求比时间重要的场景，提升系统访问速度，如分库分表。

**6. 参数调优**

可进行参数调优的层面：

- JVM（内存空间及垃圾回收算法）
- Web 容器（线程池的设置）
- 操作系统（内核参数设置）

**7. 兜底策略**

系统优化的再好也有承受极限，为保证系统稳定性，必须提供兜底策略：

- 限流（达到最大范围采取熔断，返回友好提示，而不是崩溃信息）
- 实现智能横向扩容（超过指定请求阈值时，系统根据需求自动横向扩容，如 Kubernetes）
- 提前扩容（适用于秒杀、抢购等高并发系统）

## 2 代码性能调优

### 2.1 字符串性能优化

String 对象是 Java 程序中，内存占用空间率最大的一个对象。

#### 2.1.1 String 的 JDK 优化路线

![1615182550276](assets/1615182550276.png)

**1. JDK 1.6 及以前版本**

String 对象对 char 数组进行了封装实现的对象，主要有4个成员变量：

- char 数组
- 偏移量 offset
- 字符数量 count
- 哈希值 hash

String 对象通过 offset 和 count 两个属性来定位 char[] 数组，获取字符串。

1）优势

- 高效、快速的共享数组对象
- 节省内存空间

2）劣势

可能导致内存泄漏（`String.substring()` 方法共享 char[] 数组）。

**2. JDK 1.7 至 JDK 1.8**

去掉了 offset 和 count 两个属性变量。

优势：

- String 对象的内存占用减少
- 解决了内存泄漏问题（`String.substring()` 方法不再共享 char[] 数组）

**3. JDK 1.9 及以后**

将 char[] 属性变量更改为 byte[] 字段，并添加了一个新的属性 coder（编码格式的标识）。

1）修改原因

因为 char 字节占16位，即2个字节，存储单字节编码内的字符（如 Latin1 字符）比较浪费内存空间，于是采用占用8位，即1个字节的 byte[] 数组来存放字符串。

2）coder 属性作用

计算字符串长度或者调用 `indexOf()` 方法时，需要根据此字段，计算字符串长度，coder 字段默认有0和1两个值：

- 0表示 Latin1（单字节编码）
- 1表示 UTF-16

3）优势

进一步节省 String 对象的内存占用。

#### 2.1.2 String 对象的不可变性

**1. 实现**

- String 类被 final 修饰，表示该类不可被继承；
- char[] 属性变量被 final + private 修饰，表示 String 对象不看被更改。

**2. 优势**

- 保证 String 对象的安全性，防止恶意修改；
- 保证 hash 属性值不会频繁变更，确保唯一性（如 HashMap 等容器以此才能实现 key-value 缓存功能）；
- 可实现字符串常量池。

**3. 创建字符串对象的两种方式**

①通过字符串常量的方式创建，如 `String str = "str";`，此时 JVM 会先检查该对象是否存在于字符串常量池中，如果存在则返回该对象引用，否则将其在字符串常量池中创建。

优势：减少同值字符串对象的重复创建，节约内存。

②通过新建对象的方式创建，如 `String str = new String("str");`，首先在编译类文件时，将此字符串常量放入到 class 字节码文件的常量池结构中，类加载时 `"str"` 会在常量池中创建，其次，在调用 new 时，JVM 会调用 String 的构造函数，同时将引用常量池中的 `"str"` 字符串，在堆内存中创建一个 String 对象，最后 `"str"` 引用此对象。

#### 2.1.3 String 对象的优化方案

- 字符串拼接尽量用 `StringBuilder` 代替 `+` 号
- 项目内产生大量字符串的场景下，使用 `String.intern()` 节省内存
- 字符串分割时，尽量使用 `String.indexOf()` 方法代替 `split()` 方法

**1. 字符串拼接**

字符串拼接尽量用 `StringBuilder` 代替 `+` 号。

1）编译器优化

用 `+` 号作为字符串的拼接，会被编译器优化成新建 `StringBuilder` 对象，并调用它的 `append()` 方法的方式，但是如果在循环中用 `+` 号拼接，则会循环创建 `StringBuilder` 对象，浪费资源。

2）线程安全问题

多线程中使用 `StringBuffer` 来拼接字符串，此方法被 synchronized 修饰。

> 但是如果 JVM 通过逃逸分析发现此方法并没有锁竞争，则会进行锁消除。

**2. 节省内存**

项目内产生大量字符串的场景下，使用 `String.intern()` 节省内存。

1）`intern()` 实现原理

①首先会去查看字符串常量池是否存在该对象的字符串，有则返回常量池中的字符串引用，没有则②；

②在常量池中新增该对象，并返回该对象引用。

③堆内存中原有的对象如果没有引用指向它，后续将会通过 gc 回收该引用。

2）`intern()` 优点

- 节省内存

3）`intern()` 缺点

- 数据存储过大时，遍历的时间复杂度会增加，导致效率低下（常量池内部实现类似于 HashTable）

**3. 字符串分割**

字符串分割时，尽量使用 `String.indexOf()` 方法代替 `split()` 方法。

> `split()` 方法底层通过正则表达式实现的字符串分割，使用不当可能导致回溯问题，从而引起 CPU 使用率居高不下。

### 2.2 正则表达式

正则表达式是一个用正则符号写出的公式，程序对此公式进行语法分析，建立一个语法分析书，再根据整个分析书结合正则表达式的引擎生成执行程序（状态机），用于字符匹配。

#### 2.2.1 正则表达式引擎

**1. 作用**

用于建立状态机。

**2. 分类**

实现正则表达式引擎的方式有两种：

- DFA 自动机（Deterministic Final Automata）：确定有限状态自动机
- NFA 自动机（Non deterministic Finite Automaton）：非确定有限状态自动机

**3. DFA 与 NFA 的区别**

- 构造 DFA 自动机的代价远大于 NFA 自动机
- DFA 自动机的执行效率高于 NFA 自动机
- 匹配长度为 n 的字符串，DFA 自动机的时间复杂度为 O(n)；假设 NFA 自动机的状态数为 s，则它的时间复杂度为 O(ns)（因为 NFA 自动机在匹配过程中存在大量分支和回溯）

#### 2.2.2 NFA 自动机

**1. 匹配模式**

NFA 自动机拥有三种匹配模式：

- 贪婪模式（Greedy）：在数量匹配中，如果单独使用 `+`、`?`、`*` 或 `{min,max}` 等量词时，它会匹配尽可能多的内容
- 懒惰模式（Reluctant）：尽可能少的重复匹配字符，即首先选择最小的匹配范围，匹配成功后会继续匹配剩余的字符串，用法是在 `{min,max}` 后加一个 `?`
- 独占模式（Possessive）：最大限度的匹配更多内容，匹配失败就结束匹配，用法是在 `{min,max}` 后加一个 `+`

**2. 回溯问题**

1）问题

在 NFA 自动机的贪婪模式下，匹配每发生一次失败，就引起一次回溯。

2）解决方案

使用懒惰模式或独占模式。

#### 2.2.3 正则表达式的优化

- 少用贪婪模式，多用独占模式

- 减少分支选择
- 减少捕获嵌套

**1. 少用贪婪模式，多用独占模式**

贪婪模式会引起会说问题，使用独占模式避免回溯。

**2. 减少分支选择**

分支选择类型 `(X|Y|Z)` 的正则表达式会降低性能，有几种优化方案：

- 常用的选项放前面，可以被较快匹配
- 提取共用模式，如 `(abcd|abef)` 替换为 `ab(cd|ef)`
- 简单的分支选择类型，可以使用三次 index 代替  `(X|Y|Z)`

**3. 减少捕获嵌套**

1）捕获组

概念捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显示命名的数组中，方便后面引用。

用法：一般一个 `()` 就是一个捕获组，可以嵌套，如 `(X)(Y)(Z)`，匹配时可以根据 `group(0)` 直接获取到 `(X)` 匹配的子串。

2）非捕获组

概念：非捕获组是指参与匹配却不进行氛组编号的捕获组。

用法：表达式一般由 `(?:exp)` 组成，如 `(?:X)(Y)`，匹配时会直接丢弃 `X` 子串，直接匹配 `Y`。

3）优化

减少不需要获取的分组，可提高正则表达式性能。

### 2.3 List 集合类优化

#### 2.3.1 ArrayList 与 LinkedList 的性能对比

**1. 新增元素**

| 操作                   | 时间消耗时长对比    |
| ---------------------- | ------------------- |
| 从集合头部位置新增元素 | LinkedList 耗时较短 |
| 从集合中间位置新增元素 | ArrayList 耗时较短  |
| 从集合尾部位置新增元素 | ArrayList 耗时较短  |

- ArrayList 是数组实现的，而数组是一块连续的内存空间，在添加元素到数组头部的时候，需要对头部以后的数据进行复制重排，所以效率很低；LinkedList 是基于链表实现，在添加元素的时候，首先会通过循环查找到添加元素的位置，如果要添加的位置处于 List 的前半段，就从前往后找；若其位置处于后半段，就从后往前找。因此 LinkedList 添加元素到头部是非常高效的。
- ArrayList 在添加元素到数组中间时，同样有部分数据需要复制重排，效率也不是很高；LinkedList 将元素添加到中间位置，是添加元素最低效率的，因为靠近中间位置，在添加元素之前的循环查找是遍历元素最多的操作。
- 添加元素到尾部的操作中，在没有扩容的情况下，ArrayList 的效率要高于 LinkedList。因为 ArrayList 在添加元素到尾部的时候，不需要复制重排数据，效率非常高。而 LinkedList 虽然也不用循环查找元素，但 LinkedList 中多了 new 对象以及变换指针指向对象的过程，所以效率要低于 ArrayList。

> 此份结果是基于 ArrayList 初始化容量足够，排除动态扩容数组容量的情况下进行的测试，如有动态扩容的情况，ArrayList 的效率也会降低。

**2. 删除元素**

| 操作                   | 时间消耗时长对比    |
| ---------------------- | ------------------- |
| 从集合头部位置删除元素 | LinkedList 耗时较短 |
| 从集合中间位置删除元素 | ArrayList 耗时较短  |
| 从集合尾部位置删除元素 | ArrayList 耗时较短  |

原理同上（新增元素）。

**3. 遍历元素**

| 操作         | 时间消耗时长对比   |
| ------------ | ------------------ |
| for(;;) 循环 | ArrayList 耗时较短 |
| 迭代器循环   | 耗时相当           |

LinkedList 基于链表实现的，在使用 for 循环的时候，每一次 for 循环都会去遍历半个 List，所以严重影响了遍历的效率；ArrayList 则是基于数组实现的，并且实现了 RandomAccess 接口标志，意味着 ArrayList 可以实现快速随机访问，所以for(;;)  循环效率非常高。

#### 2.3.2 ArrayList 与 LinkedList 的优化方案

- 使用 ArrayList 时，如果集合长度固定，提前初始化初始容量，防止添加时扩容消耗性能；
- 使用 LinkedList 时，遍历时使用迭代器遍历，而不是 for 循环；
- 对集合头部结点增删操作频繁的场景优先使用 LinkedList，其他场景使用 ArrayList。

### 2.4 Stream 优化

#### 2.4.1 性能对比

将常规迭代、Stream 串行迭代、Stream 并行迭代的性能进行对比，迭代循环中，对数据进行过滤、氛组操作的，测试结果如下：

| 测试方案                                     | 时间消耗时长排名                             |
| -------------------------------------------- | -------------------------------------------- |
| 多核 CPU，操作长度为 100 的 int 数组         | 常规迭代 < Stream 并行迭代 < Stream 串行迭代 |
| 多核 CPU，操作长度为 10^8 的 int 数组        | Stream 并行迭代 < 常规迭代 < Stream 串行迭代 |
| 多核 CPU，操作长度为 10^8 的对象数组过滤分组 | Stream 并行迭代 < 常规迭代 < Stream 串行迭代 |
| 单核 CPU，操作长度为 10^8 的对象数组过滤分组 | 常规迭代 < Stream 串行迭代 < Stream 并行迭代 |

#### 2.4.2 优化方案

- 尽量将服务部署在多核 CPU，并使用 Stream 并行迭代的方式处理大量数据的迭代分组等操作（如分库分表的查询操作）；
- 服务部署在单核 CPU 下时，优先使用常规迭代。

### 2.5 HashMap 优化

- 预知存储数据大小时，提前设置初始容量（初始容量 = 数据大小 / 加载因子）且数值必须为 2 的整数次幂，减少 `resize()` 操作，提高效率
- 查询操作较为频繁时，适当减少负载因子
- 希望提高堆内存利用率时，适当增加负载因子

### 2.6 IO 优化

#### 2.6.1 IO 模型

**1. 概念**





### 2.7 序列化优化

#### 2.7.1 Java 序列化

Java 的序列化缺陷：

- 无法跨语言
- 易被攻击
- 序列化后的流太大
- 序列化性能较差

**1. 无法跨语言**

Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。

**2. 易被攻击**

反序列化是调用 ObjectInputStream 上的 readObject() 方法，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化，也就是说，在反序列化字节流的过程中，该方法可以执行任意类型的代码。

> 攻击者可以创建循环对象链，然后将序列化后的对象传输到服务中反序列化，这种情况会导致 hashCode 方法被调用次数呈次方爆发式增长, 从而引发栈溢出异常。

**3. 序列化后的流太大**

序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果进行网络传输，则占用的带宽就更多，影响系统的吞吐量。

**4. 序列化性能较差**

Java 序列化中的编码耗时要比 ByteBuffer 长很多。

#### 2.7.2 优化方案

使用 Protobuf、FastJson、Kryo、Protobuf、Hessian 等序列化替换 Java 序列化。



## 3 多线程性能调优



## 4 JVM 性能调优

## 5 代码设计模式优化

## 6 MySQL 调优























