# 项目性能调优

## 1 性能调优概念

### 1.1 调优原因及目的

**1. 原因**

没有经过性能测试的系统，访问量急剧上升时，会导致系统不稳定甚至宕机。

**2. 目的**

- 提高系统性能；
- 节省公司成本。

### 1.2 调优时机

**1. 项目开发初期**

代码层面保证规范的编码：

- 减少磁盘 I/O 操作；
- 降低竞争锁的使用
- 使用低复杂度算法；
- 合理使用设计模式实现业务代码（如商品折扣红包等业务使用装饰模式）。

**2. 项目开发完成**

- 根据性能测试结果种的不足指标定向调优；
- 对日志进行分析及时修复问题。

### 1.3 调优指标

**1. CPU**

减少 CPU 占用过高的操作，占用 CPU 资源的操作：

- 代码递归导致的无限循环
- 正则表达式引起的回溯
- JVM 频繁的 Full GC
- 多线程编程造成的大量上下文切换

**2. 内存**

内存成本较高，在有限的内存中，降低内存溢出、内存泄漏等风险。

**3. 磁盘 I/O**

磁盘 I/O 读写速度较慢，尽量减少磁盘 I/O 访问次数。

**4. 网络**

提高网络带宽大小。

**5. 异常**

Java 项目中，抛出异常需要构建异常栈，对异常进行捕获和处理，此过程非常消耗系统性能。

**6. 数据库**

大量写操作的系统，优化数据库是整个系统的核心工作。

**7. 锁竞争**

减少锁竞争带来的上下文切换，降低系统性能消耗。

**8. 响应时间 RT**

响应时间（Response Time）越短越好，分为四种：

- 数据库响应时间（最耗时）：主要是写入数据到磁盘的时间消耗；
- 服务端响应时间（包含 Nginx 转发请求时间）：主要是服务端业务逻辑的时间消耗；
- 网络响应时间：主要是对传输请求及响应进行解析的时间消耗；
- 客户端响应时间：客户端含有大量逻辑处理的时间消耗（几乎没有逻辑处理的 Web、APP 客户端时间消耗可忽略不计）。

**9. 吞吐量 TPS**

吞吐量（Transaction per second）越高越好，即每秒事务处理，可分为两种：

- 磁盘吞吐量
- 网络吞吐量

1）磁盘吞吐量

磁盘吞吐量有两个关键指标：

- IOPS（Input/Output Per Second），即每秒的读写次数，主要是随机读写的场景，如小文件存储、OLTP 数据库、邮件服务器等；
- 数据吞吐量，即单位时间内可以成功传输的数据量，主要是顺序读写的场景，如电视台的视频编辑、音频/视频点播等。

2）网络吞吐量 

网络吞吐量指在不丢帧的情况下，设备能够接受的最大数据速率，影响因素如下：

- CPU
- 网卡处理能力
- 网络带宽大小
- 防火墙
- 外部接口响应时间 RT
- 磁盘 I/O

**10. 计算机资源分配使用率**

计算机资源分配使用率就像木桶效应，最高性能取决于木桶中的最短短板，有4个指标：

- CPU 占用率
- 内存使用率
- 磁盘 I/O
- 网络 I/O

**11. 负载承受能力**

负载承受能力有两个指标：

- 系统压力上升时，系统响应时间曲线变化是否平缓；
- 系统压力的上限（压力增长到系统大量抛出错误时）。

### 1.4 微基准性能测试

**1. 目标**

精准定位到某个模块或方法的性能问题。

**2. 适用场景**

适用于做一个功能模块或一个方法在不同实现方式下的性能对比，如方法加锁和不加锁的性能对比。

### 1.5 宏基准性能测试

**1. 测试环境**

需要模拟线上真实环境，包括部署方案、真实数据等。

**2. 测试场景**

测试接口时需要排除其他业务接口的干扰。

**3. 测试目标**

- 吞吐量、响应时间是否达标
- 观察最大 TPS 时各个服务器的 CPU、内存及 I/O 使用率的变化

**4. 干扰因素**

- 热身问题
- 性能测试结果不稳定
- 多 JVM 情况下的影响

1）热身问题

- 问题状况：性能测试时，系统运行的越来越快，同一接口或方法的运行速度比第一次访问快上几倍；
- 产生原因：①随着某个方法或代码块的执行次数增多，JVM 会通过即时编译器（JIT compiler，just-in-time compiler）对程序中的热点代码编译成平台相关机器码，并进行各层次的优化，并存储在内存中；②刚开始的运行阶段，JVM 会花费很长时间来全面优化代码，后续则以最高性能执行。

2）性能测试结果不稳定

- 问题状况：每次测试所用数据集都是相同的，但是测试结果确有差异；
- 产生原因：①其他进程的影响；②网络波动；③每个阶段的 JVM 垃圾回收内存分配效率的不同。

3）多 JVM 情况下的影响

- 问题状况：多个 Java 应用部署在不同的 tomcat 下，其中任意一个 JVM 都拥有整个系统的资源使用权，互相争夺抢占资源；
- 解决方案：尽量避免线上环境中一台机器部署多个 JVM 的情况。

### 1.6 调优策略

从应用层到操作系统层的几种调优策略：

- 优化代码
- 优化设计
- 优化算法
- 时间换空间
- 空间换时间
- 参数调优
- 兜底策略，确保系统稳定性

**1. 优化代码**

- 避免内存溢出等问题代码
- 优化非问题代码，如使用合适场景的集合类

**2. 优化设计**

使用合适的设计模式。

**3. 优化算法**

使用较低的时间复杂度的算法。

**4. 时间换空间**

系统对时间的要求比空间重要的场景，如 String 的 `intern()` 方法，将重复率较高的数据集存储在常量池，节省空间。

**5. 空间换时间**

系统对空间的要求比时间重要的场景，提升系统访问速度，如分库分表。

**6. 参数调优**

可进行参数调优的层面：

- JVM（内存空间及垃圾回收算法）
- Web 容器（线程池的设置）
- 操作系统（内核参数设置）

**7. 兜底策略**

系统优化的再好也有承受极限，为保证系统稳定性，必须提供兜底策略：

- 限流（达到最大范围采取熔断，返回友好提示，而不是崩溃信息）
- 实现智能横向扩容（超过指定请求阈值时，系统根据需求自动横向扩容，如 Kubernetes）
- 提前扩容（适用于秒杀、抢购等高并发系统）

## 2 代码性能调优

### 2.1 字符串性能优化

String 对象是 Java 程序中，内存占用空间率最大的一个对象。

#### 2.1.1 String 的 JDK 优化路线

![1615182550276](assets/1615182550276.png)

**1. JDK 1.6 及以前版本**

String 对象对 char 数组进行了封装实现的对象，主要有4个成员变量：

- char 数组
- 偏移量 offset
- 字符数量 count
- 哈希值 hash

String 对象通过 offset 和 count 两个属性来定位 char[] 数组，获取字符串。

1）优势

- 高效、快速的共享数组对象
- 节省内存空间

2）劣势

可能导致内存泄漏（`String.substring()` 方法共享 char[] 数组）。

**2. JDK 1.7 至 JDK 1.8**

去掉了 offset 和 count 两个属性变量。

优势：

- String 对象的内存占用减少
- 解决了内存泄漏问题（`String.substring()` 方法不再共享 char[] 数组）

**3. JDK 1.9 及以后**

将 char[] 属性变量更改为 byte[] 字段，并添加了一个新的属性 coder（编码格式的标识）。

1）修改原因

因为 char 字节占16位，即2个字节，存储单字节编码内的字符（如 Latin1 字符）比较浪费内存空间，于是采用占用8位，即1个字节的 byte[] 数组来存放字符串。

2）coder 属性作用

计算字符串长度或者调用 `indexOf()` 方法时，需要根据此字段，计算字符串长度，coder 字段默认有0和1两个值：

- 0表示 Latin1（单字节编码）
- 1表示 UTF-16

3）优势

进一步节省 String 对象的内存占用。

#### 2.1.2 String 自身的设计

**1. String 对象的不可变性**

1）实现

- String 类被 final 修饰，表示该类不可被继承；
- char[] 属性变量被 final + private 修饰，表示 String 对象不看被更改。

2）优势

- 保证 String 对象的安全性，防止恶意修改；
- 保证 hash 属性值不会频繁变更，确保唯一性（如 HashMap 等容器以此才能实现 key-value 缓存功能）；
- 可实现字符串常量池。

3）创建字符串对象的两种方式

①通过字符串常量的方式创建，如 `String str = "str";`，此时 JVM 会先检查该对象是否存在于字符串常量池中，如果存在则返回该对象引用，否则将其在字符串常量池中创建。

优势：减少同值字符串对象的重复创建，节约内存。

②通过新建对象的方式创建，如 `String str = new String("str");`，首先在编译类文件时，将此字符串常量放入到 class 字节码文件的常量池结构中，类加载时 `"str"` 会在常量池中创建，其次，在调用 new 时，JVM 会调用 String 的构造函数，同时将引用常量池中的 `"str"` 字符串，在堆内存中创建一个 String 对象，最后 `"str"` 引用此对象。

## 3 多线程性能调优

## 4 JVM 性能调优

## 5 代码设计模式优化

## 6 MySQL 调优























