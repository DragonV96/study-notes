# IO 总结

## 1 IO 流

### 1.1 概念

**1. I/O 概念**

I/O 是机器获取和交换信息的主要渠道。

**2. 流**

1）概念

在计算机中，流是一种信息的转换。

> 流是完成 I/O 操作的主要方式。

2）分类

- 输入流（InputStream）：机器或者应用程序接收外界的信息
- 输出流（OutputStream）：从机器或者应用程序向外输出的信息

合称为输入 / 输出流（I/O Streams）。

**3. IO 原理**

机器间或程序间在进行信息交换或者数据交换时，先将对象或数据转换为某种形式的流，再通过流的传输，到达指定机器或程序后，再将流转换为对象数据。

**4. 分类**

1）按功能划分

- 网络 IO
- 磁盘 IO

2）按数据划分

- 传统 I/O 的数据读取和写入是从用户空间到内核空间来回复制
- 内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入

### 1.2  Java 的 IO

**1. IO 操作类**

`java.io` 包下有 4个 IO 操作的基本类（抽象类）：

- 字节流：`InputStream`、`OutputStream`
- 字符流：`Reader`、`Writer`

![image-20210318231736553](assets/image-20210318231736553.png)

**2.字节流**

字节流的子类，以功能划分：

- 文件的读写操作：`FileInputStream`、`FileOutputStream`
- 字节数组的读写操作：`ByteArrayInputStream`、`ByteArrayOutputStream`
- 普通字符串的读写操作：`BufferedInputStream`、`BufferedOutputStream`

![image-20210318231723397](assets/image-20210318231723397.png)

**3. 字符流**

1）分类

字符流的子类，以功能划分：

- 文件的读写操作：`FileReader`、`FileWriter`
- 字符数组的读写操作：`CharArrayReader`、`CharArrayWriter`
- 字节流的读写操作：`InputStreamReader`、`OutputStreamWriter`

![image-20210318232224828](assets/image-20210318232224828.png)

2）需要 IO 字符流的原因

数据读写过程中，字符到字节必须经过转码，此过程非常耗时，如果对编码类型不确定，则容易乱码，所以 IO 流提供了一个直接操作字符的接口，方便代码对字符进行流操作。



## 2 IO 模型

### 2.1 Socket

**1. 分类**

套接字通信可以分为流式套接字（TCP）和数据报套接字（UDP）。

**2. TCP 流程**

TCP 的数据传输比较复杂，存在拆包和装包的可能，下述流程为一次最简单的 TCP 数据传输流程。

![1616139331058](assets/1616139331058.png)

①应用程序通过系统调用 socket 创建一个套接字，它是系统分配给应用程序的一个文件描述符 fd；

②应用程序会通过系统调用 bind，绑定地址和端口号，给套接字命名；

③系统会调用 listen 创建一个队列用于存放客户端进来的连接；

④服务通过系统调用 accept 来监听客户端的连接请求。

当有一个客户端连接到服务端之后，服务端就会调用 fork 创建一个子进程，通过系统调用 read 监听客户端发来的消息，再通过 write 向客户端返回信息。

### 2.2 BIO 阻塞式IO

**1. 流程**

在整个 socket 通信工作流程中，socket 的默认状态是阻塞的。

> 当发出一个不能立即完成的套接字调用时，其进程将被阻塞，被系统挂起，进入睡眠状态，一直等待相应的操作响应。

**2. 阻塞点** 

1）connect 阻塞

当客户端发起 TCP 连接请求，通过系统调用 connect 函数，TCP 连接的建立需要完成三次握手过程，客户端需要等待服务端发送回来的 ACK 以及 SYN 信号，同样服务端也需要阻塞等待客户端确认连接的 ACK 信号，也就是说 TCP 的每个 connect 都会阻塞等待，直到确认连接。

![1616140008546](assets/1616140008546.png)

2）accept 阻塞

一个阻塞的 socket 通信的服务端接收外来连接，会调用 accept 函数，如果没有新的连接到达，调用进程将被挂起，进入阻塞状态。

![1616143289046](assets/1616143289046.png)

3）read/write 阻塞

当一个 socket 连接创建成功之后，服务端用 fork 函数创建一个子进程， 调用 read 函数等待客户端的数据写入，如果没有数据写入，调用子进程将被挂起，进入阻塞状态。

![1616143598496](assets/1616143598496.png)

### 2.3 NIO 非阻塞式 IO

非阻塞 IO 模型如下图。

> 使用命令 `fcntl` 可以把 BIO 的三种阻塞操作（connect、accept、read/write）都设置为非阻塞操作。如果没有数据返回，则返回一个 EWOULDBLOCK 或 EAGAIN 错误。

![image-20210320160909617](assets/image-20210320160909617.png)



## 3 操作系统的 IO 复用机制

Linux 提供了 I/O 复用函数 select/poll/epoll，进程将一个或多个读操作通过系统调用函数，阻塞在函数操作上，系统内核会代替进程侦测多个读操作是否处于就绪状态。

### 3.1 select

**1. 数据结构**

select 底层数据结构是数组，默认限制的最大连接句柄是1024。

> 可通过修改宏定义甚至重新编译内核的方式打破这一限制。

**2. 作用**

在超时时间内，轮询监听用户进程的文件描述符上的可读可写和异常事件的发生。

**3. 实现原理**

1）源码

````C++
int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)
````

> Linux 操作系统的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个文件描述符（fd）。

select() 函数监视的文件描述符分 3 类：

- writefds（写文件描述符）
- readfds（读文件描述符）
- exceptfds（异常事件文件描述符）

2）流程

①调用 select() 函数后会阻塞，直到有描述符就绪或者超时，函数返回。

②当 select 函数返回后，可以通过函数 FD_ISSET 遍历 fdset，来找到就绪的描述符。

> fd_set 可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：
>
> ````C++
> 	void FD_ZERO(fd_set *fdset);          // 清空集合
> 	void FD_SET(int fd, fd_set *fdset);   // 将一个给定的文件描述符加入集合之中
> 	void FD_CLR(int fd, fd_set *fdset);   // 将一个给定的文件描述符从集合中删除
> 	int FD_ISSET(int fd, fd_set *fdset);  // 检查集合中指定的文件描述符是否可以读写
> ````

3）流程图

![image-20210321231630666](assets/image-20210321231630666.png)

**4. 局限性**

- fd_set 是基于数组实现的，在新增和删除 fd 时，数量过大会导致效率降低；
- 大量文件描述符的数组被整体复制到用户态和内核的地址空间之间，无论这些文件描述符是否就绪，系统开销都会随着文件描述符数量的增加而线性增大。

### 3.2 poll

**1. 数据结构**

poll 底层数据结构是链表，没有最大连接限制。

**2. 作用**

在超时时间内，轮询监听用户进程的文件描述符上的可读可写和异常事件的发生。

**3. 流程图**

![image-20210321232231420](assets/image-20210321232231420.png)

**4. 局限性**

大量文件描述符的数组被整体复制到用户态和内核的地址空间之间，无论这些文件描述符是否就绪，系统开销都会随着文件描述符数量的增加而线性增大。

### 3.3 epoll

**1. 数据结构**

epoll 底层数据结构是红黑树，增删改查的时间复杂度都为 O(n)。

> Linux 2.6 内核版本所提供。

**2. 作用**

在超时时间内，轮询监听用户进程的文件描述符上的可读可写和异常事件的发生。

**3. 实现原理**

epoll 事先通过 epoll_ctl() 来注册一个文件描述符，将文件描述符存放到内核的一个事件表中，这个事件表是基于红黑树实现的。

````C++
int epoll_ctl(int epfd, int op, int fd, struct epoll_event event)
````

- epfd：由 epoll_create() 函数生成的一个 epoll 专用文件描述符；
- op：代表操作事件类型；
- fd：表示关联文件描述符；
- event：表示指定监听的事件类型。

一旦某个文件描述符就绪时，内核会采用类似 callback 的回调机制，迅速激活这个文件描述符，当进程调用 epoll_wait() 时便得到通知，之后进程将完成相关 I/O 操作。

````C++
int epoll_wait(int epfd, struct epoll_event events,int maxevents,int timeout)
````

3）流程图

![image-20210322001441685](assets/image-20210322001441685.png)

**4. 特性**

- 大量 I/O 请求的场景下，插入和删除的性能比 select/poll 的数组 fd_set 要好；
- 不会受到 fd 数量的限制。































