# 深入理解JVM学习笔记

  * [1 内存管理](#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86)
    * [1\.1 运行时数据区域](#11-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F)
      * [1\.1\.1 程序计数器](#111-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8)
      * [1\.1\.2 Java虚拟机栈](#112-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88)
        * [局部变量表](#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8)
      * [1\.1\.3 本地方法栈](#113-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88)
      * [1\.1\.4 Java堆](#114-java%E5%A0%86)
      * [1\.1\.5 方法区](#115-%E6%96%B9%E6%B3%95%E5%8C%BA)
        * [运行时常量池](#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0)
      * [1\.1\.6 直接内存](#116-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98)
    * [1\.2 HotSpot虚拟机对象](#12-hotspot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1)
      * [1\.2\.1 对象的创建](#121-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA)
      * [1\.2\.2 对象的内存布局](#122-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80)
      * [1\.2\.3 对象的访问定位](#123-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D)
  * [2 垃圾收集器与内存分配策略](#2-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5)
    * [2\.1 对象回收](#21-%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6)
      * [2\.1\.1 引用计数算法](#211-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95)
      * [2\.1\.2 可达性分析算法](#212-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95)
      * [2\.1\.3 引用](#213-%E5%BC%95%E7%94%A8)
      * [2\.1\.4 对象彻底回收](#214-%E5%AF%B9%E8%B1%A1%E5%BD%BB%E5%BA%95%E5%9B%9E%E6%94%B6)
      * [2\.1\.5 回收方法区](#215-%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA)
    * [2\.2 追踪式垃圾收集算法](#22-%E8%BF%BD%E8%B8%AA%E5%BC%8F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95)
      * [2\.2\.1 分代收集理论](#221-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA)
      * [2\.2\.2 标记清除算法](#222-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95)
      * [2\.2\.3 标记复制算法](#223-%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95)
      * [2\.2\.4 标记整理算法](#224-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95)
      * [2\.2\.5 三个标记算法总结](#225-%E4%B8%89%E4%B8%AA%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93)
    * [2\.3 经典垃圾收集器](#23-%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8)
      * [2\.3\.1 Serial收集器](#231-serial%E6%94%B6%E9%9B%86%E5%99%A8)
      * [2\.3\.2 ParNew收集器](#232-parnew%E6%94%B6%E9%9B%86%E5%99%A8)
      * [2\.3\.3 Parallel Scavenge收集器](#233-parallel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8)
      * [2\.3\.4 Serial Old收集器](#234-serial-old%E6%94%B6%E9%9B%86%E5%99%A8)
      * [2\.3\.5 Parallel Old收集器](#235-parallel-old%E6%94%B6%E9%9B%86%E5%99%A8)
      * [2\.3\.6 CMS收集器](#236-cms%E6%94%B6%E9%9B%86%E5%99%A8)
      * [2\.3\.7 Garbage First收集器（G1）](#237-garbage-first%E6%94%B6%E9%9B%86%E5%99%A8g1)
      * [2\.3\.8 垃圾收集器对比汇总](#238-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94%E6%B1%87%E6%80%BB)
    * [2\.4 低延迟垃圾收集器](#24-%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8)
  * [3 类文件结构](#3-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84)
  * [4 虚拟机类加载机制](#4-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6)
    * [4\.3 类加载的过程](#43-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B)
      * [4\.3\.1 加载](#431-%E5%8A%A0%E8%BD%BD)
      * [4\.3\.2 验证](#432-%E9%AA%8C%E8%AF%81)

## 1 内存管理

### 1.1 运行时数据区域

![1586771622378](assets/1586771622378.png)

#### 1.1.1 程序计数器

**1. 概念**

程序计数器（Program Counter Register），是当前线程所执行的字节码的**行号指示器**。

> 线程私有的内存。

**2. 作用**

它是程序控制流的指示器，作用于以下基础功能：

- 分支
- 循环
- 跳转
- 异常处理
- 线程恢复

**3. 实现细节**

- 线程执行的是 Java 方法时，记录正在执行的虚拟机字节码指令的地址
- 线程执行本地（Native）方法时，计数器值为空（Undefined）

**4. 异常**

程序计数器是**唯一**一个在《Java虚拟机规范》中**没有**规定任何 **OutOfMemory Error** 情况的区域。

#### 1.1.2 Java虚拟机栈

**1. 概念**

Java 虚拟机栈（Java Virtual Machine Stack），是 Java 方法执行的线程内存模型。

> 线程私有的内存，生命周期与线程相同。

**2. 作用**

为 Java 方法（字节码）服务。

每个 Java 方法被执行时，Java 虚拟机栈会同步创建一个栈帧（Stack Frame），用于存储：

- 局部变量表
- 操作数栈
- 动态连接
- 方法出口

> 每个方法被调用至执行完毕的过程，对应一个栈帧在虚拟机中从入栈到出栈的过程。

**3. 异常**

- 抛出 StackOverflow Error 异常：线程请求的栈深度大于虚拟机允许的深度时。
- 抛出 OutOfMemory Error 异常：若 Java 虚拟机栈容量允许动态扩展，栈扩展无法申请到足够内存时。

> HotSpot 虚拟机的栈容量不允许动态扩展，所以它不会由于虚拟机无法扩展而导致 OutOfMemory Error 异常，但是线程申请空间失败会出现 OOM 异常。

##### 局部变量表

1）编译期的存放类型：

- Java 基本数据类型（boolean、byte、char、short、int、float、long、double）
- 对象引用（reference 类型，即【指向对象起始地址的引用指针】或【指向一个代表对象的句柄或与此对象相关的位置】）
- returnAddress 类型（指向字节码指令的地址）

2）编译期的存放方式：

以局部变量槽（Slot）表示

- 占用两个变量槽：long 和 double
- 占用一个变量槽：其余基本类型

> 局部变量表所需的内存空间在编译期间分配完成，确定局部变量槽的数量，方法运行期间不会改变大小。

#### 1.1.3 本地方法栈

**1. 作用**

本地方法栈（Java Virtual Machine Stack），为本地（Native）方法服务。

>  线程私有的内存。

**2. 异常**

- 抛出 StackOverflow Error 异常：栈深度溢出时
- 抛出 OutOfMemory Error 异常：栈扩展失败时

#### 1.1.4 Java堆

**1. 概念**

Java 堆（Java Heap）虚拟机管理的内存中最大的一块，也叫做 GC 堆。

> 线程共享的区域，虚拟机启动时创建。

**2. 作用**

存放对象实例。

- 回收内存：分代回收（新生代、老年代、永久代、Eden 空间、 From Survivor 空间、To Survivor 空间）
- 分配内存：堆中划分多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）来提升对象分配时的效率

> Java 堆可在物理内存空间上不连续，但是逻辑上是连续的。

**3. 异常**

抛出 OutOfMemory Error 异常：Java 堆没有内存分配实例，且堆也无法再次扩展时。

> Java 堆默认固定大小，但是可以通过参数 `-Xmx` 和 `-Xms` 扩展其大小。

#### 1.1.5 方法区

**1. 概念**

方法区（Method Area），堆的一个逻辑部分。

> 线程共享的区域。它也叫做“非堆”（Non-Heap），目的是与 Java 堆区分。

**2. 作用**

方法区（Method Area）存储虚拟机加载的数据：

- 类型信息
- 常量
- 静态变量
- 即时编译器编译后的代码缓存

**3. 实现方式**

使用永久代来实现方法区。

- 目的：省去了专门为方法区编写内存管理代码的工作，复用 HotSpot 的垃圾收集器管理方法区。
- 缺陷：永久代有 `-XX: MaxPermSize` 上限，默认固定大小，容易导致 Java 程序的内存溢出问题（极少数方法（如 `String::intern()` ）在不同虚拟机下有不同的表现）。

HotSpot虚拟机：

- JDK6 中放弃了永久代，逐步改为本地内存（Native Memory）实现方法区
- JDK7 移除永久代中的字符串常量池和静态变量
- JDK8 完全放弃永久代，本地内存中实现元空间（Metaspace）来代替

BEA JRockit、IBM J9 等其他虚拟机：

- 没有用永久代实现方法区，所以只要不触碰到物理可用内存上限就不会出现 OOM

> 方法区并不等价于“永久代”。

**4. 内存回收**

内存回收主要针对

- 常量池的回收
- 对类型的卸载

> 方法区与 Java 堆一样可在物理内存空间上不连续，但是逻辑上是连续的，甚至可以不实现垃圾收集。
>
> 方法区的回收条件苛刻，回收效果不理想，但有时必须回收。

**5. 异常**

抛出 OutOfMemory Error 异常：方法区无法满足新内存的分配时。

##### 运行时常量池

1）概念

运行时常量池（Runtime Constant Pool），方法区的一部分。

> 编译后的Class文件包含
>
> - 类的版本
> - 字段
> - 方法
> - 接口描述
> - 常量池表（Constant Pool Table）

常量池表用于存放编译期生成的各种

- 字面量
- 符号引用

2）作用

在类加载后存放

- 常量池表
- 符号引用翻译出来的直接引用

3）动态性

在运行期间也能将新的常量放入池中（如 String 类的 `intern()` 方法）。

4）异常

抛出 OutOfMemory Error 异常：受到方法区的限制，常量池无法申请到内存时。

#### 1.1.6 直接内存

**1. 概念**

直接内存（Direct Memory）既不是虚拟机运行时数据区的部分，也不是《Java 虚拟机规范》中定义的内存区域。

**2. 作用**

JDK 1.4的 NIO 类，通过基于通道（Channel）与缓冲区（Buffer）的 I/O 方式使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。

> 此操作能在部分场景中显著提高性能（避免了在 Java 堆 和 Native 堆中来回复制数据）。

**3. 异常**

抛出 OutOfMemory Error 异常：设置的 `-Xmx` 参数信息与各个内存区域总和大于物理内存限制（包括物理和操作系统级的限制），导致动态扩展失败时。

### 1.2 HotSpot虚拟机对象

#### 1.2.1 对象的创建

**1. 创建过程**

Java 虚拟机遇到字节码new指令时：

①检查：先检查指令参数是否能在常量池中定位到一个类的符号引用

- 若有则检查这个符号引用代表的类是否已被加载、解析和初始化过
- 没有则执行类加载过程

②分配：检查通过后为新对象分配内存，类加载完成后完全确定对象所需内存大小

③初始化：Java 虚拟机将分配到的内存空间（不包括对象头）初始化为零值（保证对象的实例字段在 Java 代码中可以不赋初始值即可直接使用）

> 若使用了 TLAB，则此操作提前至使用 TLAB 分配时进行。

④设置：Java 虚拟机对对象头（Object Header）进行必要设置

- 哪个类的实例
- 类的元数据信息寻找方式
- 对象的 Hash 值（实际上对象 Hash 值延后到真正调用 `Object::hashCode()` 时才计算）
- 对象的 GC 分代年龄
- 是否启用偏向锁

⑤构造函数：若字节码 new 指令后跟随 invokespecial指令，则 new 指令执行后立即执行 `<init>()` 方法即构造函数，在 Java 程序层面初始化对象。

> JVM 虚拟机层面：①②③④
>
> Java 程序层面：①②③④⑤

**2. 内存分配**

1）分配方式：

- 指针碰撞（Bump The Point）：Java 堆内存是绝对规整的，被使用过的内存在一边，空闲的内存在另一边，中间则是指针作为分界点的指示器，分配内存时仅需把此指针向空闲内存方向挪动一段与新对象大小相等的距离
- 空闲列表（Free List）：Java 堆内存不规整时，已被使用的内存与空闲内存相互交错，虚拟机维护一个记录可用内存块的列表，分配内存时从列表中划分一块足够大的空间给对象实例，并更新列表上的记录

2）虚拟机的分配实现

- 带空间压缩整理（Compact）能力的收集器 Serial 和 ParNew：采用指针碰撞分配内存（简单高效）。

- 基于清除（Sweep）算法的收集器 CMS：采用空闲列表分配内存（复杂）。

> CMS的实现里，设计了 Linear Allocation Buffer 的分配缓冲区，通过空闲列表拿到一大块分配缓冲区后，在此区域仍然可以使用指针碰撞的方式来分配，提高分配效率。

3）分配时的线程安全性问题解决方式：

- 对分配内存空间的操作进行同步处理，即采用 CAS 配上失败重试机制保证更新的原子性
- 内存分配的操作按线程划分在不同空间处理，即每个线程在 Java 堆中预先分配小块内存，称为本地线程分配缓冲区（TLAB），本地缓冲区用完后分配新的缓存区时再同步锁定

> 设置 `-XX: ±UseTLAB` 参数来设定是否使用 TLAB 。

#### 1.2.2 对象的内存布局

HotSpot 虚拟机里，对象在堆内存中的存储布局划分为三个部分：

- 对象头（Object Header）
- 实例数据（Instance Data）
- 对其填充（Padding）

**1. 对象头**

对象头包含两部分数据：

- 存储对象自身的运行时数据（Mark Word）
    - HashCode
    - GC 分代年龄
    - 锁状态标志
    - 线程持有的锁
    - 偏向线程ID
    - 偏向时间戳
    - 记录数组长度的数据**（对象为 Java 数组时）**
- 类型指针（即对象指向它的类型元数据的指针）

**2. 实例数据**

实例数据存储对象真正的有效信息，即代码中定义的各种类型的字段内容。

1）实例数据的的存储顺序影响因素：

- 虚拟机分配策略参数（`-XX:FieldsAllocationStyle` 参数）
- 字段在 Java 源码中定义的顺序

2）虚拟机默认的分配顺序

longs/doubles -> ints -> shorts/chars -> bytes/booleans -> OOPs（Ordinary Object Pointers）

分配条件（顺序表示优先级）：

- 相同宽度字段分配到一起存放
- 父类定义的变量存放在子类前面
- 子类较窄的变量允许插入父类变量的空隙中（节省少部分空间，前提是 `+XX:CompactFields` 参数值为 true【默认为true】）

**3. 对齐填充**

非必须的数据，仅仅起占位符的作用。

> HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，若对象实例数据部分没有对齐，则需要通过对齐填充来补全。（对象头已被设计为8字节的数据）

#### 1.2.3 对象的访问定位

对象的访问定位由虚拟机实现，主要有两种访问方式：

- 使用句柄
- 直接指针

**1. 使用句柄**

Java 堆中划分出一块内存作为句柄池，reference 中存储对象的句柄地址，句柄中包含了对象实例数据与类型数据对应的具体内存地址信息。

![1586936308361](assets/1586936308361.png)

> 优势：reference 中存储的句柄地址稳定，对象移动时（如常见的垃圾收集时移动对象）只会改变句柄中实例数据指针，无需修改 reference

**2. 直接指针**

Java 堆中的reference 中直接存储对象的内存地址。

![1586936912305](assets/1586936912305.png)

> 优势：访问对象本身时速度更快，少了一次的间接访问开销。

HotSpot 虚拟机

- 主要使用直接指针访问对象
- 例外情况下使用句柄访问（使用了 Shenandoah 收集器时会有一次额外的转发）

## 2 垃圾收集器与内存分配策略

Java 堆和方法区的内存分配和回收是动态的，垃圾收集器重点管理此部分内存。

> 程序计数器、虚拟机栈、本地方法栈等区域的内存分配和回收具备确定性，当方法或线程结束时，内存自然跟着回收。

**垃圾收集器的三大指标：**

- 内存占用（Footpoint）
- 吞吐量（Throughput）
- 延迟（Latency）

### 2.1 对象回收

#### 2.1.1 引用计数算法

**1. 概念**

对象额外存储一个引用计数器 A，被引用时 A 的值加一，引用失效时 A 的值减一。任意时刻引用计数器为零的对象即为不可使用对象。

**2. 应用案例**

- 微软 COM（Component Object Model）技术
- 使用 ActionScript3 的FlashPlayer
- Python 语言
- 应用于游戏脚本领域的 Squirrel

> 主流的 Java 虚拟机都没有选用引用计数法来管理内存，因为单纯的引用计数法无法解决对象之间相互循环引用的问题。

#### 2.1.2 可达性分析算法

**1. 概念**

可达性分析算法（Reachability Analysis），就是通过一系列“GC Roots”的根对象作为起始节点集，根据引用关系向下搜索，若某个对象到 GC Roots 间没有任何引用链相连，即从 GC Roots 到这个对象不可达，证明此对象不可再被使用。

> 引用链（Reference Chain）：搜索过程锁走过的路径。

实例：

如下图，对象 object 5、object 6、object 7 虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。

![1586957170188](assets/1586957170188.png)

**2. 组成**

Java 技术体系中，固定可作为 GC Roots 的对象：

- Java 虚拟机栈中引用的对象（栈帧中的局部变量表），如线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
- 方法区中类静态属性引用的对象，如 Java 类的引用类型静态变量
- 方法区中常量引用的对象，如字符串常量池（String Table）的引用
- 本地方法栈中 JNI 引用的对象
- Java 虚拟机内部的引用，如基本类型的包装类对象，常驻的异常对象（如 NullPointException、OutOfMemory Error），系统类加载器
- 所有被同步锁（synchronized关键字）持有的对象
- 反应 Java 虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存
- 其他临时性的对象，如关联区域的对象

#### 2.1.3 引用

四种引用强度依次减弱

- 强引用（Strongly Reference）
- 软引用（Soft Reference）
- 弱引用（Weak Reference）
- 虚引用（Phantom Reference）

**1. 强引用**

实现：new 关键字对应的引用赋值。

回收条件：只要强引用关系存在，垃圾收集器就不会回收被引用的对象。

**2. 软引用**

定义：描述有用但非必须的对象。

实现：`SoftReference` 类实现

回收条件：系统发生内存溢出异常前，会把软引用对象列进回收范围中进行第二次回收。（若这次回收依然内存不足则抛出内存溢出异常）

**3. 弱引用**

定义：描述但非必须的对象。

实现：`WeakReference` 类实现

回收条件：下一次垃圾收集发生时被回收。

**4. 虚引用**

定义：对象的虚引用完全不会影响其生存时间，又称为幽灵引用或幻影引用。（无法通过虚引用获取对象实例）

实现：`PhantomReference` 类实现

目的：在此对象被收集器回收时收到一个系统通知。

#### 2.1.4 对象彻底回收

对象被彻底回收的需要经过两次标记过程：

①可达性分析后发现没有与 GC Roots 相连的引用链，则被第一次标记，随后进行一次筛选。

> 筛选此对象是否有必要执行 `finalize()`，对象没有覆盖  `finalize()` 方法，或者者 `finalize()` 方法已被虚拟机调用过，则没有必要执行。

②有必要执行 `finalize()` 时，会将对象放在 F-Queue 队列中，由一条虚拟机自动建立的低调度优先级的 Finalizer 线程去 “执行” 它们的 `finalize()` 方法，稍后被第二次标记，随后彻底回收。

> 此处的执行只是触发方法开始运行，但不保证等待它运行结束。（因为若对象的 `finalize()` 方法执行缓慢甚至发生死循环时，将导致 F-Queue 队列的其他对象处于永久等待，进而导致整个内存回收子系统崩溃）

※注意：`finalize()` 方法（官方不推荐使用）的效果尽量用 try-finally 或其他方式代替。

#### 2.1.5 回收方法区

**1. 特性**

方法区垃圾回收

- 效率较低
- 回收条件苛刻

> 《Java虚 拟机规范》中可以不要求虚拟机在方法区中实现垃圾收集，如：JDK 11 的 ZGC 收集器不支持类卸载。

**2. 回收内容**

- 废弃的常量
- 不再使用的类型

1）废弃的常量的回收条件

- 没有任何对象引用此常量
- 虚拟机没有其他地方引用此常量
- 此时发生内存回收，且垃圾收集器判断有必要将其回收

2）不再使用的类型的**允许**回收条件

- 该类所有的实例已被回收（即 Java 堆中不存在该类机器任何派生子类的实例）
- 加载该类的类加载器已被回收（如 OSGi、JSP的重加载等）
- 该类对应的 java.lang.Class 对象没有被任何地方引用，且任何地方都无法通过反射访问该类的方法

> 允许回收条件：表示没有引用了不一定会回收。

**3. JVM 参数**

HotSpot 虚拟机的 Xnoclassgc 参数控制是否要对类型进行回收。

查看类加载和卸载信息：

- Product 版虚拟机：`verbose: class` `-XX:+TraceClassLoading`
- FastDebug 版虚拟机：`-XX:+TraceClassUnLoading`

### 2.2 追踪式垃圾收集算法

垃圾收集算法分为两类

- 引用计数式垃圾收集（Reference Counting GC）
- 追踪式垃圾收集（Tracing GC）

> 引用计数式垃圾收集又称为直接垃圾收集。（主流 Java 虚拟机均未涉及）
>
> 追踪式垃圾收集又称为间接垃圾收集。

#### 2.2.1 分代收集理论

**1. 背景**

分代收集理论建立在三个分代假说之上：

- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消灭
- 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数

**2. 分类**

分代收集的分类：

- 部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集
    - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集
    - 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集*（Major GC 有争议）*
    - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集
- 整堆收集（Full GC）：指收集整个 Java 堆和方法区的垃圾收集

**3. 应用案例**

- 老年代收集：CMS 收集器独有
- 混合收集：G1 收集器独有

#### 2.2.2 标记清除算法

**1. 概念**

标记清除算法分为 “标记” 和 “清除” 两个阶段：

- 方式一：标记回收对象，统一回收所有被标记的对象
- 方式二：标记存活的对象，统一回收所有未被标记的对象

标记清除算法图解

![1587017635845](assets/1587017635845.png)

**2. 缺点**

- 执行效率不稳定（Java 堆中大量对象中的大部分是需要回收的对象时，必须进行大量标记和清除的动作，导致这两个过程的执行效率随对象数量增长而降低）
- 会使内存空间碎片化（标记、清除之后会产生大量不连续的内存碎片，导致 JVM 需要分配较大对象时连续内存不足而再次触发垃圾收集动作）

#### 2.2.3 标记复制算法

**1. 背景**

标记复制算法基于1969年 Fenichel 提出的半区复制（Semispace Copyting）。

1）半区复制算法：将可用内存按容量划分为两块大小相等的部分，每次只用其中一块，这块内存快用完时将存活的对象复制到另一块上，然后清理掉之前用过的内存空间

2）半区复制算法特性：

优点：

- 存活对象较少时，资源消耗较少
- 内存分配实现简单，运行高效（没有内存空间碎片的复杂情况，只需移动堆顶指针即可）

缺点：

- 存活对象较多时，会产生大量的内存间复制的开销
- 浪费一半的可用内存

3）标记复制算法图解

![1587017780857](assets/1587017780857.png)

**2. Appel 式回收**

1）背景

Appel式回收是在1989年 Andrew Appel 提出的更优化的半区复制分代策略。

2）流程

①把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间

②分配内存只使用 Eden 和其中一块 Survivor

③垃圾收集时，将 Eden 和 Survivor 中的存活对象一次性复制到 另外一块 Survivor 上，然后清理掉 Eden 和 Survivor 空间

> HotSpot 虚拟机默认 **Eden 和 Survivor** 的大小比例是**8：1**。

3）逃生门机制

当 Survivor 空间不足以容纳一次 Minor GC 后存活的对象时，依赖其他区域（大多为老年代）进行分配担保（Handle Promotion）。

4）应用案例

- HotSpot 虚拟机的 Serial 收集器
- HotSpot 虚拟机的 ParNew 收集器

#### 2.2.4 标记整理算法

**1. 概念**

标记过程同标记清除算法，但不清理回收对象，后续让所有存活对象移动到内存空间一端，然后清理存活对象边界以外的内存。

标记整理算法图解

![1587029400333](assets/1587029400333.png)

**2. 特性**

优点：

- 分配内存效率高
- 没有内存碎片

缺点：

在老年代这样有大量对象存活的区域回收，移动存活对象并更新对象引用时

- 资源消耗巨大
- 用户程序短时间内不可用

#### 2.2.5 三个标记算法总结

1）标记清除算法与标记整理算法的本质区别：

- 标记清除算法是一种非移动式的回收算法
- 标记整理算法是一种移动式的回收算法

2）对象移动角度

- 移动对象内存回收时更复杂
- 不移动对象内存分配时更复杂

3）垃圾收集的角度

- 不移动对象停顿时间更短甚至没有停顿
- 移动对象程序的吞吐量会更大

> 吞吐量的实质是赋值器（Mutator，垃圾收集的用户程序）与收集器的效率总和。

4）应用案例

- Parallel Scavenge 收集器基于标记整理算法，关注吞吐量
- CMS 收集器主要基于标记清除算法（面临空间碎片过多时采用标记整理算法收集一次，使内存规整）

### 2.3 经典垃圾收集器

![1587091376258](assets/1587091376258.png)

- Young generation 新生代
- Tenured generation 老年代
- 连线表示可以搭配使用
- JDK 9 图案表示在 JDK 9 中的组合搭配被废弃掉了

> 并行（Parallel）：同一时刻，多条垃圾收集器线程之间协同工作，此时用户线程处于等待状态。
>
> 并发（Concurrent）：同一时刻，垃圾收集器线程与用户线程同时运行，此时户线程的吞吐量受到影响。

#### 2.3.1 Serial收集器

**1. 目标**

缩短垃圾收集时用户线程的停顿时间。

**2. 特性**

- 垃圾收集面向新生代区域
- 收集效率最高的单线程收集器
- 额外内存消耗（Memory Footprint）最小
- 停顿时间在十几至一百多毫秒

**3. 原理**

![1587982948513](assets/1587982948513.png)

- 基于标记复制算法
- 单线程垃圾收集器
- 垃圾收集时须暂停所有工作线程直到它收集结束（Stop the world）

**4. 适用场景**

客户端模式下的 HotSpot 虚拟机。

#### 2.3.2 ParNew收集器

**1. 目标**

缩短垃圾收集时用户线程的停顿时间。

**2. 特性**

- 垃圾收集面向新生代区域
- 唯一能与 CMS 收集器配合工作的垃圾收集器
- 首个支持并发的垃圾收集器
- 首个退出历史舞台的垃圾收集器

> JDK 9 开始 ParNew + CMS 组合不再被官方推荐，取消了 ParNew + Serial Old 和 Serial + CMS 两套收集器组合的支持，取消了 `-XX:+UseParNewGC` 。

**3. 原理**

![1587982906580](assets/1587982906580.png)

Serial 收集器的多线程版本，与其共用大部分代码。

- 基于标记复制算法
- 能并行收集的多线程垃圾收集器
- 垃圾收集时须暂停所有工作线程直到它收集结束（Stop the world）

**4. 适用场景**

多核处理器下的服务端的 HotSpot 虚拟机。

**5. JVM 参数**

- `-XX:+UseConcMarkSweepGC`  激活 CMS 收集器
- `-XX:±UseParNewGC` 强制指定或禁用 ParNew 收集器
- `-XX:ParallelGCThreads` 限制垃圾收集的线程数

#### 2.3.3 Parallel Scavenge收集器

**1. 目标**

达到一个可控制的吞吐量（Throughput）。

> 吞吐量指处理器用于运行用户代码的时间与处理器总消耗时间的比值。

$$
吞吐量=\frac{运行用户代码时间}{运行用户代码时间 + 运行垃圾收集时间}
$$

**2. 特性**

- 垃圾收集面向新生代区域
- 可开启垃圾收集的自适应的调节策略（GC Ergonomics）

> 垃圾收集的自适应的调节策略是指虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整如下参数以提供最适合的停顿时间或者最大的吞吐量：
>
> 1）`-Xmn` 新生代的大小
>
> 2）`-XX:SurvivorRatio` Eden 与 Survivor 区域比例
>
> 3）`-XX:PretenureSizeThreshold` 晋升老年代对象大小

**3. 原理**

- 基于标记复制算法
- 能并行收集的多线程垃圾收集器

**4. 适用场景**

服务端模式下的 HotSpot 虚拟机。

**5. JVM 参数**

- `-XX:MaxGCPauseMillis` 控制最大垃圾收集停顿时间（大于0的毫秒数）

    > 缩短垃圾收集停顿时间是以牺牲吞吐量和新生代空间为代价换取的，不是越短越好。

- `-XX:GCTimeRatio` 直接设置吞吐量大小（0 ~ 100 的整数，默认99）

- `-XX:+UseAdaptiveSizePolicy` 开启垃圾收集的自适应的调节策略（开启前虚拟机内存数据和上述两个参数需要提前设定好）

#### 2.3.4 Serial Old收集器

**1. 目标**

缩短垃圾收集时用户线程的停顿时间。

**2. 用途**

服务端模式下：

- 在 JDK 5 及以前的版本中，配合 Parallel Scavenge 收集器使用
- 作为 CMS 收集器失败时的后预案，在并发收集发生 Concurrent Mode Failure 时使用

**3. 原理**

![1587981824242](assets/1587981824242.png)

Serial 收集器的老年代的单线程版本。

- 基于标记整理算法
- 单线程垃圾收集器

**4. 适用场景**

客户端模式下的 HotSpot 虚拟机。

#### 2.3.5 Parallel Old收集器

**1. 目标**

同 Parallel Scavenge收集器。

**2. 特性**

- 垃圾收集面向老年代区域
- 其他同 Parallel Scavenge收集器

**3. 原理**

![1587982610633](assets/1587982610633.png)

Parallel Scavenge 收集器的老年代版本。

- 基于标记整理算法
- 其他同 Parallel Scavenge收集器

**4. 适用场景**

- 注重吞吐量的场景
- 处理器资源较为稀缺的场合

#### 2.3.6 CMS收集器

CMS（全称 Concurrent Mark Sweep）并发标记收集器。

**1. 目标**

获取最短回收停顿时间。

**2. 特性**

优点：

- 并发收集
- 低停顿

缺点：

- 会产生浮动垃圾
- 收集结束时产生大量空间碎片，导致触发 Full GC
- 不符合职责分离的设计原则

**3. 原理**

![1587101135690](assets/1587101135690.png)

基于标记清除算法，清理流程分为四个步骤：

1）初始标记（CMS initial mark）

标记 GC Roots 能直接关联到的对象（需停顿用户线程，速度快）。

2）并发标记（CMS concurrent makr）

从 GC Roots 的直接关联对象开始便利整个对象图的过程，（并发执行，无需停顿用户线程，耗时长）。

3）重新标记（CMS remark）

修正并发标记期间，因用户程序同时运行导致增量更新的对象标记记录，（需停顿用户线程，执行速度仅次于初始标记）。

4）并发清除（CMS concurrent sweep）

清理删除掉标记阶段判断的回收对象，（并发执行，无需停顿用户线程）。

**4. 适用场景**

服务端模式下的 HotSpot 虚拟机。

**5. JVM 参数**

- `-XX:CMSInitialingOccupancyFraction` 设置 CMS 的触发百分比（根据老年代回收频率调整）

    > jDK 5 默认为68%，JDK 6 默认为92%。
    >
    > 设置太高会因为浮动垃圾（Floating Garbage）过多出现并发失败（Concurrent Model Failure），此时会临时启用 Serial Old 来重新回收老年代区域，导致用户线程停顿时间过长，性能降低。

- `-XX:+UseCMSCompactAtFullCollection` 解决空间碎片问题（默认开启，JDK 9 开始废弃）

- `-XX:CMSFullGCsBeforeCompaction` 进行Full GC 前进行碎片整理的间隔次数（默认0，表示每次进入 Full GC时都进行碎片整理，JDK 9 开始废弃）

**6. CMS 收集器的变种**

增量式并发收集器（Incremental Concurrent Mark Sweep/i-CMS）

1）目标

处理器核心不足四个时，降低垃圾收集独占资源的时间。

2）原理

并发标记、清理时让收集器线程和用户线程交替运行。

> jDK 7 开始被弃用， JDK 9 发布时 i-CMS 被完全废弃。

#### 2.3.7 Garbage First收集器（G1）

G1 收集器是垃圾收集器技术史上里程碑式的成果，开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。

> JDK 8 Update 40后称为"全功能的垃圾收集器"（Fully-Featured Garbage Collector）。

**1. 目标**

- 替换掉 CMS 收集器
- 建立起 “停顿时间模型”（Pause Prediction Model）
- 有限时间内获取尽可能高的收集效率

1）停顿时间模型概念

是指能够支持指定在长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过 N 毫秒。

> 停顿时间模型已成为实时 Java （RTSJ）中软实时垃圾收集器的特征。

2）能建立停顿时间模型的原因

G1 收集器将 Region 作为单次回收的最小单元，可有计划地避免在整个 Java 堆中进行全区域的垃圾收集。

> 处理思路：
>
> ①G1 收集器跟踪各个 Region 里的垃圾堆积的价值（回收所得空间大小以及回收所需时间的经验值）大小
>
> ②在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的 Region （Garbage First 名字的由来）

**2. 特性**

优点：

- 支持类卸载
- 垃圾收集效果更好
- 不会产生内存空间碎片
- 有利于程序长时间运行（垃圾收集完成后能提供规整的可用内存）
- 程序为大对象分配内存空间时不容易因无法找到连续内存空间而提前触发下一次收集

缺点：

- 垃圾收集产生的内存占用（Footprint）高
- 程序运行时的额外执行负载（Overload）高

**3. 原理**

G1 收集器 Region 分区示意图

![1587108560856](assets/1587108560856.png)

- 整体基于标记整理算法，局部（两个 Region 之间）基于标记复制算法
- 面向堆内存任何组成回收集（Collection Set，简称CSet）进行回收。
- 把 Java 堆划分为多个大小相等的独立区域（Region），每个区域可根据需要动态变成 Eden 空间、Survivor 空间或老年代空间，分别采用不同策略处理。
- Region中特殊的 Humongous 区域只存储大对象，判定条件为对象大小超过 Region 一半。

> Mixed GC 模式下：回收衡量标准为哪块内存垃圾数量最多，回收收益最大。

**4. 需要解决的问题**

1）跨 Refion 引用对象问题如何解决？

使用记忆集避免全堆作为 GC Roots 扫描。

> G1 的记忆集应用更加复杂，它的每个 Region 都有其单独的记忆集，用来记录别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围内。
>
> 记忆集的底层存储结构是哈希表，Key表示 Region 起始地址， Value 表示一个集合，存储卡表的索引号。（卡表是一种双向结构，记录指针源地址和指针目的地）

2）并发标记阶段如何保证收集线程与用户线程互不干扰的运行？

> CMS 收集器采用增量更新算法实现

G1收集器通过原始快照（SATB）算法实现，程序运行过程中如果有新对象创建，G1 每个 Region 上的 TAMS（Top at Mark Start）指针把 Region 中部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须在这两个指针位置以上。

> G1 收集器默认在这两个 TAMS 指针地址以上的对象是被隐式标记过的，即存活对象，不纳入回收范围，所以内存回收速度赶不上内存分配速度时会被迫冻结用户线程执行，导致 Full GC 产生长时间 “Stop The World”。

3）怎样建立可靠的停顿预测模型？

以衰减均值（Decaying Average）为理论基础实现的。

> G1 收集器会记录每个 Region 回收耗时、每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费的成本，分析得出平均值、标准偏差和置信度等统计信息。

**5. 清理流程**

![1587107897639](assets/1587107897639.png)

分为四个步骤（没有计算用户线程运行过程中的动作，如写屏障维护记忆集的操作）：

1）初始标记

标记 GC Roots 能直接关联到的对象，并修改 TAMS 指针的值，为并发标记阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象（需停顿用户线程，耗时短）。

2）并发标记

从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出回收对象，对象图扫描完后重新处理 SATB 记录下的在并发时有引用变动的对象（并发执行，无需停顿用户线程，耗时长）。

3）最终标记

短暂暂停用户线程，用于处理并发阶段结束后仍遗留下来的少量 SATB 记录（需停顿用户线程）。

4）筛选回收

更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户期望的停顿时间来指定回收计划，可自由选择任意 Region 构成回收集，把其中的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间（涉及存活对象的移动，需停顿用户线程，多条收集器线程并行处理）。

**6. 适用场景**

面向服务应用的服务器。

**7. JVM 参数**

- `-XX:G1HeapRegionSize` 设置 Region 大小（1MB ~ 32MB，且为2的 N 次幂） 

- `-XX:MaxGCPauseMillis` 设定允许的收集停顿时间（默认200毫秒）

    > 100 ~ 300 毫秒最佳，太短会使收集器的收集速度低于分配器分配的速度，垃圾堆积导致触发 Full GC 降低性能。

#### 2.3.8 垃圾收集器对比汇总

![1588122967348](./assets/1588122967348.png)

浅色表示必须挂起用户线程，深色表示收集器与用户线程并发执行。

Init Mark 表示初始标记，Finish Mark 表示最终标记。

### 2.4 低延迟垃圾收集器

## 3 类文件结构

## 4 虚拟机类加载机制

### 4.3 类加载的过程

JVM 中类加载的过程分为三个阶段：**加载 → 连接 → 初始化。**

**连接过程**又分为三个部分：**验证 → 准备 → 解析。**

综合，即**加载 → 验证 → 准备 → 解析 → 初始化。**

#### 4.3.1 加载

**1. 类的加载过程**

①通过一个类的全限定名来获取定义此类的二进制字节流

②将此字节流所代表的静态存储结构转化为方法区的运行时数据结构

③在内存中生成一个代表此类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

**2. 二进制字节流获取方式**

- 从ZIP压缩包中读取，最终成为 JAR、EAR、WAR 格式的基础

- 从网络中获取（如Web Applet）

- 运行时计算生成（这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass() 来为特定接口生成形式为 “*$Proxy” 的代理类的二进制字节流）

- 由其他文件生成（典型场景是JSP应用，由JSP文件生成对应的Class文件）

- 从数据库中读取（场景相对较少）

- 从加密文件中获取（防Class文件被反编译的保护措施，通过加载时解密 Class 文件来保障程序运行逻辑不被窥探）


**3. 加载方式**

- 使用Java虚拟机里内置的引导类加载器来完成
- 使用用户自定义的类加载器去完成

> 定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法）。

**4. 数组的加载**

1）定义

数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。

> 数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载。

2）创建规则

①如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，则递归采用上述加载过程去加载这个组件类型，数组 C 将被标识在加载该组件类型的类加载器的类名称空间上

②如果数组的组件类型不是引用类型（例如 int[] 数组的组件类型为 int），JVM 将会把数组 C 标记为与引导类加载器关联

③数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为 public，可被所有的类和接口访问到

3）创建流程

①根据上述创建规则加载

②加载阶段结束后，JVM 外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中，方法区中的数据存储格式完全由虚拟机实现自行定义，类型数据放在方法区后，会在 Java 堆内存中实例化一个 java.lang.Class 类的对象，将其作为程序访问方法区中的类型数据的外部接口

> 加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。

#### 4.3.2 验证

验证阶段分为四个阶段执行：文件格式验证、元数据验证、字节码验证和符号引用验证。

> 从代码量和耗费的执行性能的角度上，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。

**1. 文件格式验证**

1）目的

- 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理
- 保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求

2）验证点

- 是否以魔数 0xCAFEBABE 开头
- 主、次版本号是否在当前 Java 虚拟机接受范围之内
- 常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
- CONSTANT_Utf8_info 型的常量中是否有不符合UTF-8编码的数据
- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息
- ……

3）验证方式

这阶段的验证是基于二进制字节流进行的。

> 只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段，全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。

**2. 元数据验证**

1）目的

- 对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求
- 对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息

2）验证点

- 这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）

- 这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）

- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法

- 类中的字段、方法是否与父类产生矛盾（如覆盖了父类的final字段，或者出现不符合规则的方 

    法重载，例如方法参数都一致，但返回值类型却不同等）

- ……

**3. 字节码验证**

1）目的

- 通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的

- 对类的方法体（Class 文件中的 Code 属性）进行校验分析，保证被校验类的方法在运行时不会做出危害 

    虚拟机安全的行为

2）验证点

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作（如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况）

**4. 符号引用验证**

