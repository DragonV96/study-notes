# 消息队列面试笔记

## 1 常见面试题剖析

### 1.1 为什么使用消息队列（优点）

​	问题解读：消息队列都有哪些使用场景？然后你项目里具体是什么场景？说说你在这个场景里用消息队列是什么？

​	回答大纲：你们公司有个什么业务场景，这个业务场景有个什么技术挑战，不用 MQ 的弊端，用了 MQ 之后带来的好处。

​	**消息队列常见的使用场景：解耦、异步、削峰。**

#### 1.1.1 解耦

​	**场景：**

​	A 系统发送数据到 BCD 三个系统，通过接口调用发送。

- 此时 E 系统也需要这个数据：需要修改A系统的代码调用E系统接口，系统间极度耦合，缺少灵活性。

- 此时 C 系统不需要整个数据了：需要删除A系统上调用C系统接口的代码，系统间极度耦合，缺少灵活性。

​	**解决方案：**

​	使用消息队列。A 系统产生的数据全部发送到 MQ 里去，哪个系统需要数据直接去 MQ 里面消费。新来的系统需要数据，也直接从 MQ 里消费即可；若某个系统不再需要这些数据了，取消对 MQ 消息的消费即可。

#### 1.1.2 异步

​	**场景：**

​	用户点击一个按钮后，A 系统接收到一个请求，需要在自己本地写库，同时还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近1s才返回到前端响应，此时用户体验极差。

> 一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，200ms对于用户来说没什么延迟的感觉。

​	**解决方案：**

​	使用消息队列。此时用户连续点击3次按钮，A系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，接近实时响应，体验特别流畅。

#### 1.1.3 削峰

​	**场景：**

​	每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量仅 50 个。但是每天 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统数据库是 MySQL，大量的请求涌入 MySQL，每秒钟对 MySQL执行约 5k 条 SQL。

​	一般MySQL，扛到每秒 2k 个请求就是极限了，如果每秒请求到 5k 的话，MySQL可能当场宕机，导致系统崩溃，用户也随之流失。

​	但是高峰期一过，每秒可能也就 50 个请求，系统和MySQL完全没有什么压力。

​	**解决方案：**

​	使用消息队列。高峰期每秒 5k 个请求写入 MQ，A 系统每秒最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟只拉取 2k 个请求，不超过自己每秒能处理的最大请求数量，这样下来，A 系统和数据库扛住了压力，不会宕机。

​	高峰期MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。这个短暂的高峰期积压完全没关系，高峰期一过，变成每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以A 系统就会快速将积压的消息给消费掉。

### 1.2 消息队列的优缺点

#### 1.2.1 优点

​	以上场景下对应的好处：**解耦、异步、削峰**。

#### 1.2.2 缺点

- 系统可用性降低
  系统引入的外部依赖越多，系统整体稳定性越低。本来 ABCD 四个系统和谐共存，这时加入了MQ，某天MQ挂了，整个系统随之崩溃。（衍生问题：如何保证消息队列的高可用？）
- 系统复杂度提高
  消息队列实际是一种非常复杂的架构，引入当前系统，则此系统的复杂度也随时大大提高。（衍生问题：如何保证消息没有重复消费？消息丢失如何处理？如何保证消息传递的顺序性？）
- 一致性问题
  A 系统处理完毕直接返回成功，但是BCD 三个系统中BD 两个系统写库成功，结果 C 系统写库失败，数据就不一致了。（衍生问题：如何保证消息队列数据一致性？）

### 1.3 Kafka、ActiveMQ、RabbitMQ、RocketMQ 的区别

| 特性                     | ActiveMQ                              | RabbitMQ                                           | RocketMQ                                                     | Kafka                                                        |
| ------------------------ | ------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量               | 万级，比 RocketMQ、Kafka 低一个数量级 | 同 ActiveMQ                                        | 10 万级，支撑高吞吐                                          | 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
| topic 数量对吞吐量的影响 |                                       |                                                    | topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic | topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |
| 时效性                   | ms 级                                 | 微秒级，这是 RabbitMQ 的一大特点，延迟最低         | ms 级                                                        | 延迟在 ms 级以内                                             |
| 可用性                   | 高，基于主从架构实现高可用            | 同 ActiveMQ                                        | 非常高，分布式架构                                           | 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 消息可靠性               | 有较低的概率丢失数据                  | 基本不丢                                           | 经过参数优化配置，可以做到 0 丢失                            | 同 RocketMQ                                                  |
| 功能支持                 | MQ 领域的功能极其完备                 | 基于 erlang 开发，并发能力很强，性能极好，延时很低 | MQ 功能较为完善，还是分布式的，扩展性好                      | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 |

### 1.4 如何保证消息队列的高可用？

​	问题解读：MQ 的高可用性怎么保证？你用过哪个 MQ，你就说说你对那个 MQ 的高可用性的理解。

#### 1.4.1 RabbitMQ 的高可用性