# 数据结构与算法总结

## 1 复杂度

### 1.1 时间复杂度

**1. 定义**

表示代码执行时间随数据规模增长的变化趋势，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

**2. 时间复杂度分析原则**

- 只关注循环执行次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

**3. 复杂度量级**

- 常量阶：O(1)

- 对数阶：O(logn)

- 线性阶：O(n)

- 线性对数阶：O(nlogn）

- 平方阶：O(n²）

    > 衍生：立方阶：O(n³) ··· k 次方阶：O(n^k)

- 指数阶：O(2^n)

- 阶乘阶：O(n!)

**4. 复杂度分析分类**

复杂度分析包含四个方面：

- 最好情况时间复杂度（best case time complexity）
- 最坏情况时间复杂度（worst case time complexity）
- 平均情况时间复杂度（average case time complexity）
- 均摊时间复杂度（amortized time complexity）

### 1.2 空间复杂度

**1. 定义**

表示算法的存储空间与数据规模之间的增长关系，也叫作渐进空间复杂度（asymptotic space complexity），简称空间复杂度。

**2. 复杂度量级**

- 常量阶：O(1)
- 线性阶：O(n)
- 平方阶：O(n²)
- 对数阶：O(logn)
- 线性对数阶：O(nlogn）

## 2 数据结构

数据结构：一组数据的存储结构。

### 2.1 线性表

#### 2.1.1 数组

**1. 定义**

数组（Array）是有序的元素序列。

**2. 数据结构**

它用一组连续的内存空间，来存储一组具有相同类型的数据。

**3. 复杂度分析**

- 随机访问效率高，O(1)

  > 因为在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据。

- 增删效率低，O(n)

**4. 适用场景**

- 随机访问较多的场景

**5. 为什么数组下标从0开始？**

原因一：

从数组存储的内存模型上来看，“下标”即是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0] 表示偏移为0的位置，即首地址，a[k] 就表示偏移 k 个 type_size 的位置，计算 a[k] 的内存地址需要用这个公式：

````
a[k]_address = base_address + k * type_size
````

如果数组从1开始计数，计算数组元素a[k]的内存地址就会变为：

````
a[k]\_address = base_address + (k-1) * type_size
````

对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于  CPU 来说，多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。

原因二：

历史原因，C 语言设计者用0开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿 C 语言，降低学习成本。

#### 2.1.2 链表

**1. 定义**

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

**2. 数据结构**

存储数据和其他节点的指针（引用），无需一组连续的内存空间。

>对链表进行频繁的插入、删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，Java 中有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

**3. 分类**

有三种常见的链表结构：

- 单链表
- 双向链表
- 循环链表

**4. 复杂度分析**

- 随机访问效率低，O(n)

  > 链表在内存中并不是连续存储，所以
  > 对CPU缓存不友好，没办法有效预读。

- 增删效率高，O(1)

- 双向链表在删除给定指针指向的结点的情况下，时间复杂度为O(1)

  > 因为双向链表中的结点已经保存了前驱结点的指针，不需要再像单链表那样从前往后遍历。

**5. 适用场景**

- 增删操作较多的场景

**6. 如何实现 LRU 缓存淘汰算法？**

常见的缓存淘汰策略有三种：

- 先进先出策略FIFO（First In，First Out）
- 最少使用策略LFU（Least Frequently Used）
- 最近最少使用策略LRU（Least Recently Used）

#### 2.1.3 栈

**1. 定义**

限定仅在表尾进行插入和删除操作的线性表。

**2. 数据结构**

在一端插入和删除数据，且满足后进先出、先进后出的特性。

**3. 分类**

有两种常见的栈结构：

- 顺序栈：用数组实现的栈
- 链式栈：用链表实现的栈

**4. 适用场景**

- Java 虚拟机栈的实现场景
- 括号匹配
- 浏览器的前进后退

#### 2.1.4 队列



## 3 算法

算法：操作数据的一组方法。

