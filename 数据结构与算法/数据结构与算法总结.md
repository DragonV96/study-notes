# 数据结构与算法总结

## 1 复杂度

### 1.1 时间复杂度

**1. 定义**

表示代码执行时间随数据规模增长的变化趋势，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

**2. 时间复杂度分析原则**

- 只关注循环执行次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

**3. 复杂度量级**

- 常量阶：O(1)

- 对数阶：O(logn)

- 线性阶：O(n)

- 线性对数阶：O(nlogn）

- 平方阶：O(n²）

    > 衍生：立方阶：O(n³) ··· k 次方阶：O(n^k)

- 指数阶：O(2^n)

- 阶乘阶：O(n!)

**4. 复杂度分析分类**

复杂度分析包含四个方面：

- 最好情况时间复杂度（best case time complexity）
- 最坏情况时间复杂度（worst case time complexity）
- 平均情况时间复杂度（average case time complexity）
- 均摊时间复杂度（amortized time complexity）

### 1.2 空间复杂度

**1. 定义**

表示算法的存储空间与数据规模之间的增长关系，也叫作渐进空间复杂度（asymptotic space complexity），简称空间复杂度。

**2. 复杂度量级**

- 常量阶：O(1)
- 线性阶：O(n)
- 平方阶：O(n²)
- 对数阶：O(logn)
- 线性对数阶：O(nlogn）

## 2 数据结构

数据结构：一组数据的存储结构。

### 2.1 线性表

#### 2.1.1 数组

**1. 定义**

数组（Array）是有序的元素序列。

**2. 数据结构**

它用一组连续的内存空间，来存储一组具有相同类型的数据。

**3. 复杂度分析**

- 随机访问效率高，O(1)

  > 因为在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据。

- 增删效率低，O(n)

**4. 适用场景**

- 随机访问较多的场景

**5. 为什么数组下标从0开始？**

原因一：

从数组存储的内存模型上来看，“下标”即是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0] 表示偏移为0的位置，即首地址，a[k] 就表示偏移 k 个 type_size 的位置，计算 a[k] 的内存地址需要用这个公式：

````
a[k]_address = base_address + k * type_size
````

如果数组从1开始计数，计算数组元素a[k]的内存地址就会变为：

````
a[k]\_address = base_address + (k-1) * type_size
````

对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于  CPU 来说，多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。

原因二：

历史原因，C 语言设计者用0开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿 C 语言，降低学习成本。

#### 2.1.2 链表

**1. 定义**

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

**2. 数据结构**

存储数据和其他节点的指针（引用），无需一组连续的内存空间。

>对链表进行频繁的插入、删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，Java 中有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

**3. 分类**

有三种常见的链表结构：

- 单链表
- 双向链表
- 循环链表

**4. 复杂度分析**

- 随机访问效率低，O(n)

  > 链表在内存中并不是连续存储，所以
  > 对CPU缓存不友好，没办法有效预读。

- 增删效率高，O(1)

- 双向链表在删除给定指针指向的结点的情况下，时间复杂度为O(1)

  > 因为双向链表中的结点已经保存了前驱结点的指针，不需要再像单链表那样从前往后遍历。

**5. 适用场景**

- 增删操作较多的场景

**6. 如何实现 LRU 缓存淘汰算法？**

常见的缓存淘汰策略有三种：

- 先进先出策略FIFO（First In，First Out）
- 最少使用策略LFU（Least Frequently Used）
- 最近最少使用策略LRU（Least Recently Used）

#### 2.1.3 栈

**1. 定义**

限定仅在表尾进行插入和删除操作的线性表。

**2. 数据结构**

在一端插入和删除数据，且满足后进先出、先进后出的特性。

**3. 分类**

有两种常见的栈结构：

- 顺序栈：用数组实现的栈
- 链式栈：用链表实现的栈

**4. 适用场景**

- Java 虚拟机栈的实现场景
- 括号匹配
- 浏览器的前进后退

#### 2.1.4 队列

**1. 定义**

限定在队头（front）进行删除操作，而在队尾（rear）进行插入操作的线性表。

**2. 数据结构**

在队头（front）进行删除操作，而在队尾（rear）进行插入操作，且满足先进先出的特性。

**3. 分类**

从数据结构上划分，有2种常见的队列结构：

- 顺序队列：用数组实现的队列
- 链式队列：用链表实现的队列

从功能上划分，有种队列结构：

- 循环队列
- 阻塞队列
- 并发队列

**4. 适用场景**

- 线程池任务排队
- 锁机制的实现
- 异步消息处理

## 3 算法

算法：操作数据的一组方法。

### 3.1 递归

**1. 定义**

去的过程叫“递”，回来的过程叫“归”。

**2. 满足条件**

递归需要满足三个条件：

- 一个问题的解可以额分解为几个子问题的解。
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。
- 存在递归终止条件。

**3. 问题**

- 警惕堆栈溢出。
  - 解决方案：限制递归最大深度，抛异常。
- 重复计算。
  - 解决方案：利用散列表保存计算过的结果，每次递归前判断一次。

### 3.2 排序

**1. 目的**

将一组“无序”的记录序列调整为“有序”的记录序列。

**2. 特性**

- 执行效率
- 内存消耗
- 稳定性

1）执行效率的影响因素

- 最好情况、最坏情况、平均情况时间复杂度
- 时间复杂度的系数、常数 、低阶
- 比较次数和交换（或移动）次数

2）内存消耗

算法的内存消耗可以通过空间复杂度来衡量。

> 原地排序算法，指空间复杂度是 O(1) 的排序算法。

3）稳定性

果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

**3. 线性排序算法总结**

| 排序     | 时间复杂度 | 稳定性 | 原地排序 |
| -------- | :--------: | :----: | :------: |
| 冒泡排序 |   O(n²)    |   √    |    √     |
| 插入排序 |   O(n²)    |   √    |    √     |
| 选择排序 |   O(n²)    |   ×    |    √     |
| 快速排序 |  O(nlogn)  |   ×    |    √     |
| 归并排序 |  O(nlogn)  |   √    |    ×     |
| 计数排序 |   O(n+k)   |   √    |    ×     |
| 桶排序   |    O(n)    |   √    |    ×     |
| 基数排序 |   O(dn)    |   √    |    ×     |

k 是数据范围，d 是维度。

